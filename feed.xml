<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JBake</title>
    <link>http://rundis.github.io/blog/</link>
    <atom:link href="http://rundis.github.io/blog//feed.xml" rel="self" type="application/rss+xml" />
    <description>JBake Bootstrap Template</description>
    <language>en-gb</language>
    <pubDate>Sat, 24 Jan 2015 18:04:33 +0100</pubDate>
    <lastBuildDate>Sat, 24 Jan 2015 18:04:33 +0100</lastBuildDate>

    <item>
      <title>Bootifying my ring app</title>
      <link>http://rundis.github.io/blog//2015/bootify-ring.html</link>
      <pubDate>Mon, 19 Jan 2015 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">2015/bootify-ring.html</guid>
      	<description>
	&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_a_little_background&quot;&gt;A little background&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A few weeks back I noticed a tweet about &lt;a href=&quot;https://github.com/boot-clj/boot&quot;&gt;boot-clj&lt;/a&gt;. This weekend I finally had some time to look into whether it could
be a viable alternative to &lt;a href=&quot;https://github.com/technomancy/leiningen&quot;&gt;Leiningen&lt;/a&gt; for our apps or not.
We have a couple of ring based apps running as uberjars, so I decided to try to make a boot build for one of the projects. For the purpose of this blogpost however
I&amp;#8217;ve created a sample app. Source available on &lt;a href=&quot;https://github.com/rundis/boot-sample&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_why_bother_with_an_alternative_when_there_is_leiningen&quot;&gt;Why bother with an alternative when there is Leiningen ?&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I haven&amp;#8217;t been in the clojuresphere all that long.
I do have a history as java and groovy developer and have been through a history of using &lt;a href=&quot;http://ant.apache.org/&quot;&gt;ant&lt;/a&gt;,
&lt;a href=&quot;http://maven.apache.org/&quot;&gt;maven&lt;/a&gt; and lately &lt;a href=&quot;https://www.gradle.org/&quot;&gt;gradle&lt;/a&gt; for my builds.
In terms of development experience Leiningen is definately a step up from all of them. However I feel Leiningen has left me longing
as soon as my builds have become a bit more elaborate (testing javascript, transpiling, create artifacts, upload to repo, run migrations
deploy to different environments etc). I&amp;#8217;m sure all of this is achievable with Lein, but is it really architected to excel for that purpose ?
TBH I&amp;#8217;d love to see gradle get some serious clojure love, but it doesn&amp;#8217;t seem to be coming anytime soon. Maybe boot will be my next build tooling love :)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Reading up a bit on boot checked a few boxes for some of my longings though:&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Your build doesn&amp;#8217;t have to be all declarative&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Sensible abstractions and libraries to allow you to compose and extend your build using the full power of clojure&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Compose build pipelines somewhat similar to how you would compose middlewares in ring&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Task is the fundamental building block&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tasks typically works on immutable filesets (files treated as values, you never touch the filesystem directly yourself !)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Possibility of complete classpath isolation at task level&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Great repl and commandline support.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;#8230; and surely a lots more&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_lein_boot&quot;&gt;Lein &amp;#8594; Boot&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_leningen_project&quot;&gt;Leningen project&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;project.clj&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint clojure language-clojure&quot;&gt;&lt;code&gt;(defproject boot-sample &quot;0.1.0&quot;
  :description &quot;Boot sample application&quot;
  :url &quot;https://github.com/rundis/boot-sample&quot;
  :min-lein-version &quot;2.0.0&quot;
  :dependencies [[org.clojure/clojure &quot;1.6.0&quot;]
                 [compojure &quot;1.2.1&quot;]
                 [liberator &quot;0.12.2&quot;]
                 [ring/ring-jetty-adapter &quot;1.3.1&quot;]
                 [ring/ring-json &quot;0.3.1&quot;]
                 [bouncer &quot;0.3.1&quot;]
                 [io.aviso/pretty &quot;0.1.14&quot;]]
  :ring {:handler boot-sample.core/app                       &lt;b&gt;(1)&lt;/b&gt;
         :port 3360}
  :profiles {:dev {:plugins [[lein-ring &quot;0.8.13&quot;]]
                   :test-paths ^:replace []}
             :test {:dependencies [[midje &quot;1.6.3&quot;]]
                    :plugins [[lein-midje &quot;3.1.3&quot;]]
                    :test-paths [&quot;test&quot;]
                    :resource-paths [&quot;test/resources&quot;]}})

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The entry point for my ring app&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The above project is a really simple project definition. To run my app I just have to execute:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint bash language-bash&quot;&gt;&lt;code&gt;lein ring uberjar
java -jar target/boot-sample-0.1.0-standalone.jar&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;core.clj&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint clojure language-clojure&quot;&gt;&lt;code&gt;(ns boot-sample.core
  (:require [ring.middleware.params :refer [wrap-params]]
            [ring.middleware.keyword-params :refer [wrap-keyword-params]]
            [ring.middleware.json :refer [wrap-json-params]]
            [compojure.core :refer [defroutes ANY GET]]
            [liberator.core :refer [defresource resource]]))

(defn index-handler [req]
  &quot;Hello Boot sample (or maybe Lein still)&quot;)

(defresource booters
  :available-media-types       [&quot;application/json&quot;]
  :allowed-methods             [:get]
  :handle-ok                   (fn [ctx] [{:id &quot;Pod1&quot;} {:id &quot;Pod 2&quot;}]))

(defroutes app-routes
  (ANY &quot;/&quot; [] index-handler)
  (ANY &quot;/booters&quot; [] booters))


(def app (-&amp;gt; app-routes
             wrap-keyword-params
             wrap-json-params
             wrap-params))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Hey. Hang on. There is no main method here, how can the java -jar command work without one ?
Well, because the ring plugin creates one for us.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint bash language-bash&quot;&gt;&lt;code&gt;cat target classes/boot_sample/core/main.clj&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;gives us&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint clojure language-clojure&quot;&gt;&lt;code&gt;(do
  (clojure.core/ns boot-sample.core.main
   (:require ring.server.leiningen)
                   (:gen-class))
  (clojure.core/defn -main []
    (ring.server.leiningen/serve
     (quote {:ring {:auto-reload? false,
                    :stacktraces? false,
                    :open-browser? false,
                    :port 3360,
                    :handler boot-sample.core/app}}))))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;That&amp;#8217;s useful to know in case boot-clj doesn&amp;#8217;t happen to have a ring task that does something similar.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_boot_me_up&quot;&gt;Boot me up&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Boot comes with a range of predefined tasks that I can compose to get quite close to the Leiningen build above.
I&amp;#8217;ll focus on getting that uberjar up and running.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I could have done it all on the command line or in the boot repl, but lets just be a little declarative (still functions don&amp;#8217;t worry!).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;build.boot&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint clojure language-clojure&quot;&gt;&lt;code&gt;(set-env!
 :resource-paths #{&quot;src&quot;}                                &lt;b&gt;(1)&lt;/b&gt;
 :dependencies &apos;[[org.clojure/clojure &quot;1.6.0&quot;]
                 [compojure &quot;1.2.1&quot;]
                 [liberator &quot;0.12.2&quot;]
                 [ring/ring-jetty-adapter &quot;1.3.1&quot;]
                 [ring/ring-json &quot;0.3.1&quot;]
                 [bouncer &quot;0.3.1&quot;]
                 [io.aviso/pretty &quot;0.1.14&quot;]])

(task-options!
 pom {:project &apos;boot-Sample
      :version &quot;0.1.0&quot;}
 aot {:namespace &apos;#{boot-sample.core}}                  &lt;b&gt;(2)&lt;/b&gt;
 jar {:main &apos;boot_sample.core                           &lt;b&gt;(3)&lt;/b&gt;
      :manifest {&quot;Description&quot; &quot;Sample boot app&quot;
                 &quot;Url&quot; &quot;https://github.com/rundis/boot-sample&quot;}})


(deftask build
  &quot;Build uberjar&quot;
  []
  (comp (aot) (pom) (uber) (jar)))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;To bundle your sources in the output jar, you have to specify src as a resource-path. A small gotcha there.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We need to aot our core.clj namespace so that java -jar can invoke it&amp;#8217;s main method&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We need to help java -jar with the location of our main class in the jar&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;However you might remember from above that there is no main method in core.clj.
So the last piece of the puzzle is to add one. It&amp;#8217;t not that hard.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint clojure language-clojure&quot;&gt;&lt;code&gt;(ns boot-sample.core
  (:require [ring.middleware.params :refer [wrap-params]]
            [ring.middleware.keyword-params :refer [wrap-keyword-params]]
            [ring.middleware.json :refer [wrap-json-params]]
            [compojure.core :refer [defroutes ANY GET]]
            [liberator.core :refer [defresource resource]]
            [ring.adapter.jetty :as jetty])                                &lt;b&gt;(1)&lt;/b&gt;
  (:gen-class))                                                            &lt;b&gt;(2)&lt;/b&gt;


;; ... the other stuff

(defn -main []
  (jetty/run-jetty app {:port 3360}))                                     &lt;b&gt;(3)&lt;/b&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Using the jetty ring adapter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The :gen-class directive generates the necessary stuff for our main method to be invokable from java
during aot compilation&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fire away&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Note&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;At the time of writing there was a regression in boot that caused aot to fail.
I needed to build boot from source, should be fixed in the next release though.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint bash language-bash&quot;&gt;&lt;code&gt;git clone git@github.com:boot-clj/boot.git
cd boot/boot/core
lein install&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now all is set to try it out:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint bash language-bash&quot;&gt;&lt;code&gt;boot build
java -jar target/boot-sample-0.1.0.jar&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_all_is_well_then&quot;&gt;All is well then ?&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Unfortunately not quite. For uberjar projects it seems boot-clj at the time of writing has some serious
performance challenges.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;div class=&quot;title&quot;&gt;On my machine generating the uberjar takes:&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Leiningen : 12 seconds&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;boot-clj  : 46 seconds !&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It&amp;#8217;s not like Leiningen is lightning fast in the first place. But for this scenario boot just doesn&amp;#8217;t cut it.
I reported an &lt;a href=&quot;https://github.com/boot-clj/boot/issues/94&quot;&gt;issue&lt;/a&gt; and got prompt responses from the developers
which can only be a good sign.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_concluding_remarks&quot;&gt;Concluding remarks&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;My initial question of whether or not I feel we could use boot for our current projects gets a thumbs down for now.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I think boot-clj carries a lot of promise and have some really great ideas. It&amp;#8217;s going to be interesting to
see if boot-clj becomes a viable alternative to leiningen. I suppose a porting and/or interop story with lein
and lein plugins might be needed in addition to maturing both the model and obviously its performance characteristics.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I&amp;#8217;m certainly keen on trying it out more. I might try out the clojurescript support next and maybe churn out some custom tasks
just for fun.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Groovy Light Table Plugin</title>
      <link>http://rundis.github.io/blog//2014/groovy_repl.html</link>
      <pubDate>Mon, 19 May 2014 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">2014/groovy_repl.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A short demonstration of the repl like capabilities of my Light Table Groovy plugin (&lt;a href=&quot;https://github.com/rundis/LightTable-Groovy&quot;&gt;https://github.com/rundis/LightTable-Groovy&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;http://www.youtube.com/embed/5ji8RR2A4gQ&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Creating and using snippets in Light Table</title>
      <link>http://rundis.github.io/blog//2014/lt-snippets.html</link>
      <pubDate>Tue, 6 May 2014 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">2014/lt-snippets.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A short introduction to my Light Table Snippets plugin (&lt;a href=&quot;https://github.com/rundis/lt-snippets&quot;&gt;https://github.com/rundis/lt-snippets&lt;/a&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;http://www.youtube.com/embed/I6iuXOw3HDQ&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>JavaScript testing with Light Table and Buster.JS</title>
      <link>http://rundis.github.io/blog//2014/instabuster_part2.html</link>
      <pubDate>Mon, 21 Apr 2014 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">2014/instabuster_part2.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Second part of the intro to the Light Table Buster plugin (&lt;a href=&quot;https://github.com/busterjs/lt-instabuster&quot;&gt;https://github.com/busterjs/lt-instabuster&lt;/a&gt;)
This time demonstrating some of the more advanced features.&lt;/p&gt;
&lt;/div&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;http://www.youtube.com/embed/jYDiAVbPL8I&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>JavaScript testing with Light Table and Buster.JS</title>
      <link>http://rundis.github.io/blog//2014/instabuster_part1.html</link>
      <pubDate>Mon, 17 Mar 2014 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">2014/instabuster_part1.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Intro to the Light Table Buster plugin (&lt;a href=&quot;https://github.com/busterjs/lt-instabuster&quot;&gt;https://github.com/busterjs/lt-instabuster&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;http://www.youtube.com/embed/WKHWazblpbc&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>A Groovy Light Table client - Step 2: Evaluating Code</title>
      <link>http://rundis.github.io/blog//2014/gr_lt_part2.html</link>
      <pubDate>Sun, 23 Feb 2014 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">2014/gr_lt_part2.html</guid>
      	<description>
	&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_background&quot;&gt;Background&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is the second post in my series &quot;A Groovy Light Table client&quot;. A blog series about steps I take when trying to build a Groovy plugin for Light Table.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this post I will take you through some of the steps I went through to get Light Table to evaluate groovy (script) code and show results inline in the editor.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/blog/2014/lt_groovy_eval.png&quot; alt=&quot;lt groovy eval&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_how_did_we_get_here&quot;&gt;How did we get here ?&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_evaluate_contents_of_editor_cmd_ctrl_shift_enter&quot;&gt;Evaluate contents of editor (cmd/ctrl + shift + enter)&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint clojure language-clojure&quot;&gt;&lt;code&gt;(behavior ::on-eval
          :desc &quot;Groovy: Eval current editor&quot;
          :triggers #{:eval}
          :reaction (fn [editor]
                      (object/raise groovy :eval! {:origin editor
                                                   :info (assoc (@editor :info)
                                                           :code (ed/-&amp;gt;val editor)
                                                           :meta {:start 0, :end (ed/last-line editor)})})))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This behavior triggers on &quot;:eval&quot;, which is triggered to any editor (on cmd/ctrl + shift + enter in default key mapping). We just get hold of the text from the editor and gather some meta info  and trigger a &quot;:eval!&quot; behavior on the groovy &quot;mother&quot; object defined in the previous blog post.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_evaluate_current_line_selection&quot;&gt;Evaluate current line/selection&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint clojure language-clojure&quot;&gt;&lt;code&gt;(behavior ::on-eval.one
          :desc &quot;Groovy: Eval current selection&quot;
          :triggers #{:eval.one}
          :reaction (fn [editor]
                      (let [pos (ed/-&amp;gt;cursor editor)
                            info (conj (:info @editor)
                                  (if (ed/selection? editor)
                                    {:code (ed/selection editor) :meta {:start (-&amp;gt; (ed/-&amp;gt;cursor editor &quot;start&quot;) :line)
                                                                        :end (-&amp;gt; (ed/-&amp;gt;cursor editor &quot;end&quot;) :line)}}
                                    {:pos pos :code (ed/line editor (:line pos)) :meta {:start (:line pos) :end (:line pos)}}))]
                        (object/raise groovy :eval! {:origin editor :info info}))))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The only difference here is that we gather the code for the current line or current selection. Then we trigger the same behavior as for evaluating the whole editor.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_our_groovy_eval&quot;&gt;Our groovy Eval!&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint clojure language-clojure&quot;&gt;&lt;code&gt;(behavior ::eval!
          :triggers #{:eval!}
          :reaction (fn [this event]
                      (let [{:keys [info origin]} event
                            client (-&amp;gt; @origin :client :default)]
                        (notifos/working &quot;Evaluating groovy...&quot;)
                        (clients/send (eval/get-client! {:command :editor.eval.groovy
                                                         :origin origin
                                                         :info info
                                                         :create try-connect})
                                      :editor.eval.groovy info
                                      :only origin))))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This behavior is what actually sends off a eval request to the groovy client. Quite a lot happens under the hood (by help of inbuilt LightTable behaviors):&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It tries to find a client (connection) for the editor
If no connection exists it will try to create a new one. On create it will invoke the try-connect function that we defined for the gui connect/connect bar behavior in the previous blog post
Once connected it will jsonify our parameters and send them off to our groovy client&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;The JSON might look something like:&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint javascript language-javascript&quot;&gt;&lt;code&gt;[89,
&quot;editor.eval.groovy&quot;,
  {&quot;line-ending&quot;:&quot;\n&quot;,
   &quot;name&quot;:&quot;sample.groovy&quot;,
   &quot;type-name&quot;:&quot;Groovy&quot;,
   &quot;path&quot;:&quot;/Users/mrundberget/Library/Application Support/LightTable/plugins/Groovy/sample.groovy&quot;,
   &quot;mime&quot;:&quot;text/x-groovy&quot;,
   &quot;tags&quot;:[&quot;editor.groovy&quot;],
   &quot;code&quot;:&quot;println \&quot;hello\&quot;&quot;,
   &quot;meta&quot;:{&quot;start&quot;:22,&quot;end&quot;:22}}]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Notes&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The first param is the client id for the editor that triggered the behavior. This client Id doesn&amp;#8217;t represent the same as a connection id (ref previous blog post). Many editors may share the same connection !&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The second param is the command (our groovy client will of course support many different commands, this is one of them)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The third and last parameter is our info. The code is the essential bit, but some of the meta information, like line info comes in handy when handling the response later on&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_the_actual_groovy_evaluation&quot;&gt;The actual groovy evaluation&lt;/h3&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_command_dispatch&quot;&gt;Command dispatch&lt;/h4&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;ltClient.withStreams { input, output -&amp;gt;
  try {
    input.eachLine { line -&amp;gt;
    def (currentClientId, command, data) = new JsonSlurper().parseText(line)
    switch (command) {
    case &quot;client.close&quot;:
      stop()
      break
    case &quot;editor.eval.groovy&quot;:
      evalGroovy(data, currentClientId)
      break
   default:
     log &quot;Invalid command: $command&quot;
  }
  // ...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We parse any lines received from Light Table and based on the command received invokes the appropriate handler. In this case evalGroovy.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_eval_groovy&quot;&gt;Eval groovy&lt;/h4&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;private void evalGroovy(data, currentClientId) {
  def evalResult = scriptExecutor.execute(data.code)

  def resultParams = [meta: data.meta]
  if (evalResult.out) {
    resultParams &amp;lt;&amp;lt; [out: evalResult.out]
  }
  if(evalResult.exprValues) {
    resultParams &amp;lt;&amp;lt; [result: convertToClientVals(evalResult.exprValues)]
  }

  if (!evalResult.err) {
    data = [currentClientId?.toInteger(), &quot;groovy.res&quot;, resultParams]
  } else {
    data = [currentClientId?.toInteger(), &quot;groovy.err&quot;, [ex: evalResult.err] + resultParams]
  }
  sendData data
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The first and most significant line is where we evaluate the groovy code received. This post would be too long if we went into all the details of what it does, but here&amp;#8217;s a high-level summary:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We basically create a GroovyShell and compile our code to a script. Normally that would just compile a Script class. However we  wish to collect a lot more information than you typically would get from default groovy script execution. So we do an AST transformation on the script class and add a custom abstract script class as a base class for the compiled script class.  This allows us to inject behavior and wrap statement execution (all compiled into the script for optimal performance).  That way we are able to collect information about values for most types of statements. We collect line number and value (each line could end up having many values :-) )
We run the script (capturing system.out and system.err).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;div class=&quot;title&quot;&gt;The function returns:&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Anything written to standard out (println etc)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Errors if any and line number for error where possible&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A list for of maps with line number and value(s)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Most of the AST stuff is not something I&amp;#8217;ve written. It&amp;#8217;s been contributed by Jim White after I posted a question on the groovy-user mailing list. I asked for advice on which way to proceed and the response from the groovy community was awesome. Jim in particular was more than eager to contribute to the plugin. OpenSource rocks ! So when I say we, I sometimes mean we literally.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Anyways, based on the results of the script execution we notify Light Table to trigger either a &quot;:groovy.res&quot; behavior or a &quot;groovy.err&quot; behavior.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The json response for sendData for a successful execution might look something like:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint javascript language-javascript&quot;&gt;&lt;code&gt;[89,
 &quot;groovy.res&quot;,
 {&quot;meta&quot;:{&quot;start&quot;:22,&quot;end&quot;:23},&quot;out&quot;:&quot;hello\nmama\n&quot;,&quot;result&quot;:[{&quot;line&quot;:1,&quot;values&quot;:[&quot;null&quot;]},{&quot;line&quot;:2,&quot;values&quot;:[&quot;null&quot;]}]}]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_handling_the_evaluation_results_in_light_table&quot;&gt;Handling the evaluation results in Light Table&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint clojure language-clojure&quot;&gt;&lt;code&gt;(defn notify-of-results [editor res]
  (doseq [ln (:result res)]
    (let [lineNo (+ (:line ln) (-&amp;gt; res :meta :start) -1)]
      (object/raise editor :editor.result (clojure.string/join &quot; &quot; (:values ln)) {:line lineNo :start-line lineNo}))))

(behavior ::groovy-res
          :triggers #{:groovy.res}
          :reaction (fn [editor res]
                      (notifos/done-working)
                      (when-let [o (:out res)] (.log js/console o))
                      (notify-of-results editor res)))

(defn notify-of-error [editor res]
  (let [lineNo (+ (-&amp;gt; res :ex :line) (-&amp;gt; res :meta :start) -1)]
    (object/raise editor :editor.exception (:ex res) {:line lineNo :start-line lineNo&apos;})))

(behavior ::groovy-err
          :triggers #{:groovy.err}
          :reaction (fn [editor res]
                      (object/raise editor :groovy.res res)
                      (notify-of-error editor res)))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;These are the behavior definitions that handles either successful or evaluation of scripts with errors. Basically we:
Print to the Light Table Console anything that was captured to system.out/system.err by our groovy evaluation
Show inline results for each line, multiple results for a line are space separated. For showing inline results we are using a predefined Light Table behavior (:editor.result)
If the behavior is to handle an error, we show evaluation results up until the script exception. In addition we display details (stack trace) for the exception at the line in the script it occurred&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_wiring_it_all_up&quot;&gt;Wiring it all up&lt;/h3&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_groovy_behaviors&quot;&gt;groovy.behaviors&lt;/h4&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint clojure language-clojure&quot;&gt;&lt;code&gt;{:+ {:app [(:lt.objs.plugins/load-js [&quot;codemirror/groovy.js&quot;, &quot;groovy_compiled.js&quot;])]
     :clients []
     :editor.groovy [:lt.plugins.groovy/on-eval
                     :lt.plugins.groovy/on-eval.one
                     :lt.plugins.groovy/groovy-res
                     :lt.plugins.groovy/groovy-err
                     [:lt.object/add-tag :watchable]]
     :files [(:lt.objs.files/file-types
              [{:name &quot;Groovy&quot; :exts [:groovy] :mime &quot;text/x-groovy&quot; :tags [:editor.groovy]}])]
     :groovy.lang [:lt.plugins.groovy/eval!
                   :lt.plugins.groovy/connect]}}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The eval and results/err behaviors are defined for the editor tag. So they are only applicable for editors marked as groovy editors. Any editor open with a file name ending in .groovy will automatically be attached to a editor.groovy tag. (You can also set it manually cmd+space &amp;#8594; &quot;Editor: Set current editor syntax&quot;).
The &quot;:eval!&quot; behavior is defined for the :groovy.lang tag. Its tied to our groovy mother object just like the connect behavior. These behaviors are totally groovy client specific, whilst the other behaviors are less so (although not exactly generic as they are now?)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_wrap_up&quot;&gt;Wrap up&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A little bit of plumbing was needed to get this set up. But the hard parts was really coming up with the groovy AST transformation stuff. I guess by now you might have started getting an inkling that Light Table is fairly composable ? It really is super flexible. You don&amp;#8217;t like the behavior for handling inline results for the groovy plugin ? You could easily write your own and wire it up in your user.behaviors file in Light Table. It&amp;#8217;s wicked cool, actually it really is your editor !&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Yesterday I released version 0.0.2 of the Groovy LightTable plugin. Its available through the Light Table plugin manager, or if you wish to play with the code or maybe feel like contributing feel free to fork the repo at : &lt;a href=&quot;https://github.com/rundis/LightTable-Groovy&quot;&gt;https://github.com/rundis/LightTable-Groovy&lt;/a&gt;. Pull requests are welcome.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;So where to next ? I&amp;#8217;d really like to try and create an InstaRepl editor for the plugin. A groovy script editor that evaluates code as you type. There&amp;#8217;s gotta be one or two challenges related to that. A quick win might be to provide groovy api documentation from inside Light Table. I&amp;#8217;ll let you know what happens in the next post.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Note&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Disclaimer: I might have misunderstood some nuances of Light Table, but hopefully I&amp;#8217;m roughly on track. If you see anything glaringly wrong, do let me know.&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>A Groovy Light Table client - Step 1: Connecting the client</title>
      <link>http://rundis.github.io/blog//2014/gr_lt_part1.html</link>
      <pubDate>Sun, 16 Feb 2014 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">2014/gr_lt_part1.html</guid>
      	<description>
	&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_building_a_plugin_in_light_table&quot;&gt;Building a plugin in Light Table&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is the first post in (hopefully) a series of blog posts about the various steps I go through when trying to create a plugin for Light Table. I have decided to try to create a Groovy plugin. I chose Groovy to ensure there was at least one technology fairly familiar to me. I have just started using Light Table, I have no previous experience with ClojureScript and I have just recently started writing some Clojure beyond the basic tutorials.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The short term goal is for the plugin to provide inline results and maybe an instarepl of some sort for groovy scripts.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rundis/LightTable-Groovy&quot;&gt;LightTable-Groovy&lt;/a&gt; is the name of my plugin project and you can find the latest source there. It might be a couple of steps ahead of the blog posts though !&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_documentation&quot;&gt;Documentation&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Light Table was made &lt;a href=&quot;http://www.chris-granger.com/2014/01/07/light-table-is-open-source/&quot;&gt;open source&lt;/a&gt; in january and documentation for plugin developers is a little sparse.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;div class=&quot;title&quot;&gt;So to have something to go by I decided to use some of the other language plugins as inspiration:&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LightTable/Python&quot;&gt;Python plugin&lt;/a&gt; (comes bundled/under the light table umbrella)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/existentialmutt/lt-ruby&quot;&gt;Ruby Instarepl&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jetaggart/light-haskell&quot;&gt;Haskell plugin&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I haven&amp;#8217;t worked with any of the above mentioned languages, but they did provide enough inspiration to deduce how a Light Table client might interact.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;BTW. A quick starter just to get you up an running with a hello world plugin could be this screen cast by Mike Haney.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_connecting_a_client_process_overview&quot;&gt;Connecting a client - Process overview&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Before we dwelve into the code It&amp;#8217;s a good idea to have a high level understanding of what we are trying to achieve !&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;div class=&quot;title&quot;&gt;A couple of use cases that needs to be supported:&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Evaluate current selection or current line of groovy code and present results (preferably inline)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Evaluate contents of current editor and present results&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Provide as much info about the results of each statement as possible&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(Maybe need to evaluate line/statement by statement)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For a future instarepl, any change in the editor will trigger an evaluation
It becomes evident that our plugin needs to provide some kind of process that reacts to events from light table.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;div class=&quot;title&quot;&gt;A default pattern for achieving this has been devised for Light Table and roughly equates to the following steps:&lt;/div&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;A connect event is triggered from Light Table (you need to set up your plugin to trigger that event?). Typically the connect event can be invoked manually from the connect bar in light table, or it can be triggered implicetly when evaluating code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You fire of a process - Using inbuilt support from Light Table you start a process either a shell script or whatever really. I created a shell script that sets some environment stuff and then basically kicks off a groovy script. Light table provides a tcp/ip port and a unique client id which you need to forward to the process.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a tcp client: In your process you create a tcp client using the given port&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Send ack message: Send a json message with client id and an event name (behavior) to Light Table (through the tcp connection!)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Confirm handshake for process: In your process (i.e. not the tcp connection!) write &quot;Connected&quot; to standard out. (&quot;Connected&quot; is just what the other plugins use, you could use  anything you like as long as it matches the connect behaviors(handlers) you provide inside light table.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Listen for events: Now you are connected and given you have set up your behaviors in Light Table correctly, your new connection should be reported as connected and shown in the Light Table connect bar. Now you listen for events on your tcp client and provides appropriate responses back to Light Table accordingly. (Handling this is the subject of a future blog post)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_behaviors_for_connecting_from_groovy_cljs&quot;&gt;Behaviors for connecting (from groovy.cljs):&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint clojure language-clojure&quot;&gt;&lt;code&gt;(defn run-groovy[{:keys [path name client] :as info}]
  (let [obj (object/create ::connecting-notifier info)
        client-id (clients/-&amp;gt;id client)
        project-dir (files/parent path)]
    (object/merge! client {:port tcp/port
                           :proc obj})
    (notifos/working &quot;Connecting..&quot;)
    (proc/exec {:command binary-path
                :args [tcp/port client-id project-dir]
                :cwd plugin-dir
                :env {&quot;GROOVY_PATH&quot; (files/join (files/parent path))}
                :obj obj})))

(defn check-groovy[obj]
  (assoc obj :groovy (or (::groovy-exe @groovy)
                         (.which shell &quot;groovy&quot;))))

(defn check-server[obj]
  (assoc obj :groovy-server (files/exists? server-path)))

(defn handle-no-groovy [client]
  (clients/rem! client)
  (notifos/done-working)
  (popup/popup! {:header &quot;We couldn&apos;t find Groovy.&quot;
                 :body &quot;In order to evaluate in Groovy files, Groovy must be installed and on your system PATH.&quot;
                 :buttons [{:label &quot;Download Groovy&quot;
                            :action (fn []
                                      (platform/open &quot;http://gvmtool.net/&quot;))}
                           {:label &quot;ok&quot;}]}))

(defn notify [obj]
  (let [{:keys [groovy path groovy-server client]} obj]
    (cond
     (or (not groovy) (empty? groovy)) (do (handle-no-groovy client))
     :else (run-groovy obj))
    obj))

(defn check-all [obj]
  (-&amp;gt; obj
      (check-groovy)
      (check-server)
      (notify)))

(defn try-connect [{:keys [info]}]
  (.log js/console (str &quot;try connect&quot; info))
  (let [path (:path info)
        client (clients/client! :groovy.client)]
    (check-all {:path path
                :client client})
    client))


(object/object* ::groovy-lang
                :tags #{:groovy.lang})


(def groovy (object/create ::groovy-lang))

(scl/add-connector {:name &quot;Groovy&quot;
                    :desc &quot;Select a directory to serve as the root of your groovy project... then again it might not be relevant...&quot;
                    :connect (fn []
                               (dialogs/dir groovy :connect))})
(behavior ::connect
                  :triggers #{:connect}
                  :reaction (fn [this path]
                              (try-connect {:info {:path path}})))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Notes:&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;scl/add-connector: This statement adds a connect dialog to our groovy plugin. You select a root directory and upon selection the ::connect behavior is triggered&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;::connect basically responds with invoking a method for connecting. This does some sanity checks and if all goes well ends up invoking  run-groovy.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;run-groovy : Fires up our groovy (server) process&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;def groovy   is basically the &quot;mother&quot; object of our plugin. It helps us scope behaviors and commands&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_the_server_part_ltserver_groovy&quot;&gt;The server part (LTServer.groovy)&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;import groovy.json.*

params = [
  ltPort:   args[0].toInteger(),
  clientId: args[1].toInteger() // light table generated id for the client (connection)
]

logFile = new File(&quot;server.log&quot;)

def log(msg) {
  logFile &amp;lt;&amp;lt; &quot;${new Date().format(&apos;dd.MM.yyyy mm:hh:sss&apos;)} - $msg\n&quot;
}

client = null
try {
  client = new Socket(&quot;127.0.0.1&quot;, params.ltPort)
} catch (Exception e) {
  log &quot;Could not connect to port: ${params.ltPort}&quot;
  throw e
}

def sendData(data) {
  client &amp;lt;&amp;lt; new JsonBuilder(data).toString() + &quot;\n&quot;
}
// ack to Light Table
sendData (
  [
    name: &quot;Groovy&quot;,
    &quot;client-id&quot;: params.clientId,
    dir: new File(&quot;&quot;).absolutePath,
    commands: [&quot;editor.eval.groovy&quot;],
    type: &quot;groovy&quot;
  ]
)
println &quot;Connected&quot; // tells lighttable we&apos;re good

client.withStreams {input, output -&amp;gt;
  while(true) {
  // insert code to listen for events from light table and respond to those (eval code etc)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_notification_of_successful_connection&quot;&gt;Notification of successful connection&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint clojure language-clojure&quot;&gt;&lt;code&gt;(behavior ::on-out
          :triggers #{:proc.out}
          :reaction (fn [this data]
                      (let [out (.toString data)]
                        (object/update! this [:buffer] str out)
                        (if (&amp;gt; (.indexOf out &quot;Connected&quot;) -1)
                          (do
                            (notifos/done-working)
                            (object/merge! this {:connected true}))
                          (object/update! this [:buffer] str data)))))

(behavior ::on-error
          :triggers #{:proc.error}
          :reaction (fn [this data]
                      (let [out (.toString data)]
                        (when-not (&amp;gt; (.indexOf (:buffer @this) &quot;Connected&quot;) -1)
                          (object/update! this [:buffer] str data)
                          ))
                      ))

(behavior ::on-exit
          :triggers #{:proc.exit}
          :reaction (fn [this data]
                      ;(object/update! this [:buffer] str data)
                      (when-not (:connected @this)
                        (notifos/done-working)
                        (popup/popup! {:header &quot;We couldn&apos;t connect.&quot;
                                       :body [:span &quot;Looks like there was an issue trying to connect
                                              to the project. Here&apos;s what we got:&quot; [:pre (:buffer @this)]]
                                       :buttons [{:label &quot;close&quot;}]})
                        (clients/rem! (:client @this)))
                      (proc/kill-all (:procs @this))
                      (object/destroy! this)
                      ))

(object/object* ::connecting-notifier
                :triggers []
                :behaviors [::on-exit ::on-error ::on-out]
                :init (fn [this client]
                        (object/merge! this {:client client :buffer &quot;&quot;})
                        nil))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The above behaviors basically handles signaling success, error or connection exits for our groovy client. As you can see in ::on-out this is where we check standard out from the process for the string &quot;Connected&quot;, to signal success.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_wiring_up_behaviors_behaviors_groovy&quot;&gt;Wiring up behaviors (behaviors.groovy)&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint clojure language-clojure&quot;&gt;&lt;code&gt;{:+ {:app [(:lt.objs.plugins/load-js [&quot;codemirror/groovy.js&quot;, &quot;groovy_compiled.js&quot;])]
     :clients []
     :editor.groovy []
     :files [(:lt.objs.files/file-types
              [{:name &quot;Groovy&quot; :exts [:groovy] :mime &quot;text/x-groovy&quot; :tags [:editor.groovy]}])]
     :groovy.lang [:lt.plugins.groovy/connect]}}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The important part in terms on the connection is the wiring of the connect behavior to &quot;:groovy.lang&quot;. This is needed for groovy to appear as a connection item in the light table connect bar.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&quot;codemirror/groovy.js&quot; deserves a special mention. This is what provides syntax highlighting for our groovy files (defined in the :files vector). The syntax highlighting is provided by the groovy mode module from CodeMirror.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_wrapping_up&quot;&gt;Wrapping up&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;So what have we achieved. Well we now have a connection to Light Table from an external process that can listen and respond to events from Light Table. For the purposes of this blog post series, its a Groovy client that hopefully pretty soon will be able to evaluate groovy scripts and respond with evaluation results. We didn&amp;#8217;t pay much attention to it, but we also got syntax highlighting of our Groovy files complements of CodeMirror.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It took a while to grok how the connection part worked. Once I did understand roughly what was needed I was a bit annoyed with myself for messing about so much. I&amp;#8217;m hoping this post might help others to avoid some of the mistakes I stumbled into.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Javascript testing in your JVM projects using Gradle and BusterJS</title>
      <link>http://rundis.github.io/blog//2013/buster-plugin.html</link>
      <pubDate>Mon, 19 Aug 2013 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">2013/buster-plugin.html</guid>
      	<description>
	&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When I first started looking at testing in javascript land a while back I quickly felt lost in space.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Filled with questions like;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;which framework(s) to choose ?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;how do I get framework x to work from my IDE ?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;more importantly how to I manage to include the javascript tests in my CI builds ?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;how can I avoid repetitive setup pain across projects ?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;why is it such a hassle getting started ?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I can&amp;#8217;t say I have answered any of the questions above fully, but I have taken some strides in the right direction.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_buster_js&quot;&gt;Buster.JS&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.busterjs.org/en/latest/&quot;&gt;Buster&lt;/a&gt; is a flexible and modularized framework for writing and running your JavaScript tests.
There are others out there, but from what I could gather and based on advice from my frontend wizard colleagues I decided to give it a good go. It&amp;#8217;s still in beta, but from my experiences so far its more than mature enough for proper use in projects.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_a_few_important_aspects_about_buster_js&quot;&gt;A few important aspects about Buster.JS:&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Tests are run in real browsers (phantomjs for headless). No emulation bull
You can run tests in multiple browsers in parallell
Its really really fast
Write tests in the fashion that suits you (xUnit or spec)
Nice assertion library and integrated with Sinon.JS (powerful stubbing and spying)
&amp;#8230; and lots more&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_gradle_buster_plugin&quot;&gt;Gradle buster plugin&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For my jvm project builds I use Gradle. Maven and Ant projects that spend time with me a few weeks tend to find themselves converted. So I set out to create a buster plugin for gradle, aptly named gradle-buster-plugin. Still early days, but already it has started to prove quite valuable.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;div class=&quot;title&quot;&gt;The plugin has two high-level goals;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Allow you to easily run javascripts as part of your CI builds&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Provide you with a smooth development experience by adding value on top of whats already present in Buster.JS.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The homepage for the pluging is here: &lt;a href=&quot;https://github.com/rundis/gradle-buster-plugin&quot;&gt;https://github.com/rundis/gradle-buster-plugin&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_what_do_i_have_to_do_aka_getting_started&quot;&gt;What do I have to do ? (aka getting started)&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_installing_preconditions&quot;&gt;Installing preconditions&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Install node.js/npm - Mac: $ brew install node&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Install Buster.JS  - $ npm install buster -g&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Install Phantom.JS  - Mac: $ brew install phantomjs&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_set_up_the_buster_plugin_in_your_gradle_config&quot;&gt;Set up the buster plugin in your gradle config&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;buildscript {
    repositories { jcenter() }
    dependencies {
        classpath  &apos;org.gradle.buster:gradle-buster-plugin:0.2.4.1&apos;
    }
}

apply plugin: &apos;war&apos; // just assuming you have a war project
apply plugin: &apos;buster&apos;

build.dependsOn busterTest // hook up javascript task in the build&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_set_up_a_buster_js_configuration_file&quot;&gt;Set up a buster.js configuration file&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint javascript language-javascript&quot;&gt;&lt;code&gt;var config = module.exports;

config[&quot;Sample JSTests&quot;] = {
    environment: &quot;browser&quot;,

    libs: [&quot;src/main/webaapp/js/libs/jquery-1.10.2.js&quot;],
    sources: [&quot;src/main/web-app/js/app/**/*.js&quot;],
    tests: [&quot;src/test/js/**/*-test.js&quot;]
};&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_sample_unit&quot;&gt;Sample unit&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;So you could create a file like src/main/webapp/js/app/dummy-service.js&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint javascript language-javascript&quot;&gt;&lt;code&gt;var myapp = this.myapp || {};
myapp.services = app.services || {};
(function () {
    myapp.services.DummyService = function (my) {
        my.listTodos = function(success, error) {
            $.get(&apos;/todos/list&apos;)
               .done(function(data) {
                  success(data);
               })
               .fail(function(jqXHR, textStatus, errorThrown) {
                  error(&quot;Error getting todos&quot;)
               });
        };
        return my;
    }(myapp.services.DummyService || {});
}());&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_sample_unit_test&quot;&gt;Sample unit test&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Create a corresponding unit test in src/test/js/app/dummy-service-test.js&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint javascript language-javascript&quot;&gt;&lt;code&gt;(function () {
    buster.testCase(&quot;DummyService&quot;, {
        setUp: function() {
            this.service = myapp.services.DummyService;
            this.server = sinon.fakeServer.create();
            this.success = this.spy();
            this.error = this.spy();
        },
        tearDown: function () {
            this.server.restore();
        },
        &quot;should successfully list todos&quot;: function () {
            this.service.listTodos(this.success, this.error);
            this.server.requests[0].respond(
                200,
                { &quot;Content-Type&quot;: &quot;application/json&quot; },
                JSON.stringify([{ id: 1, text: &quot;Provide examples&quot;, done: true }])
            );

            assert.calledOnce(this.success);
        },
        &quot;should invoke error callback on errors&quot;: function () {
            this.service.listTodos(this.success, this.error);
            this.server.requests[0].respond(
                500,
                { &quot;Content-Type&quot;: &quot;application/json&quot; },
                JSON.stringify([{ id: 1, text: &quot;dummy&quot;, done: true }])
            );

            assert.calledOnce(this.error);
        }
    });
}());&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_running_the_tests_locally&quot;&gt;Running the tests locally&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint bash language-bash&quot;&gt;&lt;code&gt;$ gradle busterTest&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Test results are found in : build/busterTest-results/bustertests.xml&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Autotesting
When doing your tdd cycles its quite useful to use the autotest feature (kinda like infinitest).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint bash language-bash&quot;&gt;&lt;code&gt;$ gradle busterAutoTest&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Will leave the server running and listen for file changes in the patterns specified by the buster.js file above. So if I change the test or unit above a test run will automatically be fired off and results reported to the console. Its pretty fast so you should be able to keep a good flow going !
Just do Ctrl + C to kill the autotesting.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Multiple browsers
Its quite easy to set up just see the readme for the plugin&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;CI Server
Obviously you will need to set up the preconditions. If you&amp;#8217;re server isn&amp;#8217;t headless you have the option of testing with a few proper browsers(firefox and chrome on linux, safari if your server is mac&amp;#8230; which I doubt).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Its certainly not perfect, but with the above you have a pretty good start. Once you get over the hurdle of setting up the preconditions it really is quite pleasant to work with. You should be amazed by the performance of the tests runs if you are from a jvm background.
What about IDE integration ? With the autotest feature I can&amp;#8217;t say I have missed it much. I have my IDE and a visible console available and get instant feedback on saves in my IDE.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Smooth !&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>

  </channel> 
</rss>
