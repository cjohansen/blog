<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Rundis</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">
    <meta name="generator" content="JBake">

    <link href="/blog/css/bootstrap.min.css" rel="stylesheet">
    <link href="/blog/css/asciidoctor.css" rel="stylesheet">
    <link href="/blog/css/base.css" rel="stylesheet">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
    <link href="/blog/css/prettify.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/blog/assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/blog/assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/blog/assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="/blog/assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="favicon.ico">
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-58695124-1', 'auto');
      ga('send', 'pageview');

    </script>
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">

	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/blog/index.html">Rundis</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="/blog/about.html">About</a></li>
            <li><a href="/blog/feed.xml">Subscribe</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">

	<div class="page-header">
		<h1>Blog</h1>
	</div>
  			<a href="/blog/2015/gr_lt_status_jan2015.html"><h1>A Groovy Light Table client - Not dead (yet)</h1></a>
  			<p>25 January 2015</p>
        <p><em>Tags: </em>
		      <a href="/blog/tags/lighttable.html">lighttable</a>
	      
		      <a href="/blog/tags/groovy.html"> groovy</a>
	      
		      <a href="/blog/tags/gradle.html"> gradle</a>
	      
		      <a href="/blog/tags/clojurescript.html"> clojurescript</a>
	      </p>
  			<p><div class="sect1">
<h2 id="_background">Background</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In 2014 I blogged about the process of evolving a groovy(/gradle) plugin for Light Table from scratch.</p>
</div>
<div class="ulist">
<div class="title">Posts so far:</div>
<ul>
<li>
<p><a href="/blog/2014/gr_lt_part1.html">A Groovy Light Table client - Step 1: Connecting the client</a></p>
</li>
<li>
<p><a href="/blog/2014/gr_lt_part2.html">A Groovy Light Table client - Step 2: Evaluating Code</a></p>
</li>
<li>
<p><a href="/blog/2014/gr_lt_part3.html">A Groovy Light Table client - Step 3: Running out of quick wins</a></p>
</li>
<li>
<p><a href="/blog/2014/gr_lt_part4.html">A Groovy Light Table client - Step 4: Exploring new avenues with Gradle</a></p>
</li>
<li>
<p><a href="/blog/2014/gr_lt_part5.html">A Groovy Light Table client - Step 5: Gradle dependencies in Light Table with dagre-D3</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>I even did a <a href="/blog/2014/groovy_repl.html">screen cast</a> showing off some of the features so far.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_so_what_happened">So what happened ?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>After the summer holidays my Open Source mojo was drained, I needed a break and I went into uphill cycling mode.</p>
</div>
<div class="sect2">
<h3 id="_light_table_doubts">Light Table doubts</h3>
<div class="paragraph">
<p>First of all. I haven&#8217;t given up on Light Table I somehow even feel strongly obliged to hang in there longer
than most people given that I&#8217;ve contributed. I still use Light Table, actually more than ever because I&#8217;m currently
hacking on a clojure/clojurescript project.</p>
</div>
<div class="paragraph">
<p>In October the founder of Light Table annouced Eve and released this <a href="http://www.chris-granger.com/2014/10/01/beyond-light-table/">blog post</a>
Obviously there was initial fears that this would be the end of Light Table. However 3 of the most active contributors
to Light Table stepped up. There was a lot of visible activity initially (proper spring cleaning of the issues log).
However visible activity from Light Table has been in steady decline and the last release was 21. november of last year.</p>
</div>
<div class="paragraph">
<p>I believe they are working on moving from node-webkit to atom shell, the layout system is being revised. There is also a hack night planned
in a few days time.</p>
</div>
<div class="paragraph">
<p>I guess I just wished someone stepped up and outlined a clear road-map for Light Table and that
a steady stream of releases towards a version 1.0 started coming out :)</p>
</div>
</div>
<div class="sect2">
<h3 id="_possibilites_for_further_developments">Possibilites for further developments</h3>
<div class="paragraph">
<p>Great things are happening with gradle I believe in terms of performance and also in terms of whats possible
to achieve with the Tooling API. This opens up a whole range of oportunities to provide IDE support for languages that gradle supports.</p>
</div>
<div class="paragraph">
<p>The groovy and gradle parts of the currenty groovy plugin should probably be split with a generic gradle
plugin and specific language plugins (scala, java&#8230;) depending on that.</p>
</div>
<div class="ulist">
<div class="title">How about things like ?:</div>
<ul>
<li>
<p>Continuous unit testing - utilizing gradle builds incremental nature and the coming watcher tasks.
Couple that with showing results inline in Light Table</p>
</li>
<li>
<p>Compilation - Same story here, show compilation errors inline</p>
</li>
<li>
<p>run webapp - Run apropriate gradle task to start your webapp and fire up a browser window inline in lighttable
, maybe even hook it up with a browser debug/repl connection</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_help_needed">Help needed</h3>
<div class="paragraph">
<p>I&#8217;d love to hear if anyone has actually used the plugin and if so which parts of it.</p>
</div>
<div class="paragraph">
<p>I&#8217;m currently fully engaged in a clojure/clojurescript project, which takes all of my day time and quite a few evenings.
It puts me in a better shape to contribute to Light Table, but currently leaves me little time to do so.</p>
</div>
<div class="olist arabic">
<div class="title">That might change though, but I guess I need 2 things to happen before I pick up work on this plugin:</div>
<ol class="arabic">
<li>
<p>Some visible progress from Light Table to show that it&#8217;s intending to survive</p>
</li>
<li>
<p>Hopefully someone feels inspired to help contribute progressing the plugin (pull requests are welcome)</p>
</li>
</ol>
</div>
</div>
</div>
</div></p>
  			<a href="/blog/2015/bootify-ring.html"><h1>Bootifying my ring app</h1></a>
  			<p>19 January 2015</p>
        <p><em>Tags: </em>
		      <a href="/blog/tags/clojure.html">clojure</a>
	      
		      <a href="/blog/tags/boot.clj.html"> boot.clj</a>
	      </p>
  			<p><div class="sect1">
<h2 id="_a_little_background">A little background</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A few weeks back I noticed a tweet about <a href="https://github.com/boot-clj/boot">boot-clj</a>. This weekend I finally had some time to look into whether it could
be a viable alternative to <a href="https://github.com/technomancy/leiningen">Leiningen</a> for our apps or not.
We have a couple of ring based apps running as uberjars, so I decided to try to make a boot build for one of the projects. For the purpose of this blogpost however
I&#8217;ve created a sample app. Source available on <a href="https://github.com/rundis/boot-sample">github</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_bother_with_an_alternative_when_there_is_leiningen">Why bother with an alternative when there is Leiningen ?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I haven&#8217;t been in the clojuresphere all that long.
I do have a history as java and groovy developer and have been through a history of using <a href="http://ant.apache.org/">ant</a>,
<a href="http://maven.apache.org/">maven</a> and lately <a href="https://www.gradle.org/">gradle</a> for my builds.
In terms of development experience Leiningen is definately a step up from all of them. However I feel Leiningen has left me longing
as soon as my builds have become a bit more elaborate (testing javascript, transpiling, create artifacts, upload to repo, run migrations
deploy to different environments etc). I&#8217;m sure all of this is achievable with Lein, but is it really architected to excel for that purpose ?
TBH I&#8217;d love to see gradle get some serious clojure love, but it doesn&#8217;t seem to be coming anytime soon. Maybe boot will be my next build tooling love :)</p>
</div>
<div class="ulist">
<div class="title">Reading up a bit on boot checked a few boxes for some of my longings though:</div>
<ul>
<li>
<p>Your build doesn&#8217;t have to be all declarative</p>
</li>
<li>
<p>Sensible abstractions and libraries to allow you to compose and extend your build using the full power of clojure</p>
</li>
<li>
<p>Compose build pipelines somewhat similar to how you would compose middlewares in ring</p>
</li>
<li>
<p>Task is the fundamental building block</p>
</li>
<li>
<p>Tasks typically works on immutable filesets (files treated as values, you never touch the filesystem directly yourself !)</p>
</li>
<li>
<p>Possibility of complete classpath isolation at task level</p>
</li>
<li>
<p>Great repl and commandline support.</p>
</li>
<li>
<p>&#8230; and surely a lots more</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lein_boot">Lein &#8594; Boot</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_leningen_project">Leningen project</h3>
<div class="paragraph">
<p>project.clj</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>(defproject boot-sample "0.1.0"
  :description "Boot sample application"
  :url "https://github.com/rundis/boot-sample"
  :min-lein-version "2.0.0"
  :dependencies [[org.clojure/clojure "1.6.0"]
                 [compojure "1.2.1"]
                 [liberator "0.12.2"]
                 [ring/ring-jetty-adapter "1.3.1"]
                 [ring/ring-json "0.3.1"]
                 [bouncer "0.3.1"]
                 [io.aviso/pretty "0.1.14"]]
  :ring {:handler boot-sample.core/app                       <b>(1)</b>
         :port 3360}
  :profiles {:dev {:plugins [[lein-ring "0.8.13"]]
                   :test-paths ^:replace []}
             :test {:dependencies [[midje "1.6.3"]]
                    :plugins [[lein-midje "3.1.3"]]
                    :test-paths ["test"]
                    :resource-paths ["test/resources"]}})

</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The entry point for my ring app</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The above project is a really simple project definition. To run my app I just have to execute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint bash language-bash"><code>lein ring uberjar
java -jar target/boot-sample-0.1.0-standalone.jar</code></pre>
</div>
</div>
<div class="paragraph">
<p>core.clj</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>(ns boot-sample.core
  (:require [ring.middleware.params :refer [wrap-params]]
            [ring.middleware.keyword-params :refer [wrap-keyword-params]]
            [ring.middleware.json :refer [wrap-json-params]]
            [compojure.core :refer [defroutes ANY GET]]
            [liberator.core :refer [defresource resource]]))

(defn index-handler [req]
  "Hello Boot sample (or maybe Lein still)")

(defresource booters
  :available-media-types       ["application/json"]
  :allowed-methods             [:get]
  :handle-ok                   (fn [ctx] [{:id "Pod1"} {:id "Pod 2"}]))

(defroutes app-routes
  (ANY "/" [] index-handler)
  (ANY "/booters" [] booters))


(def app (-&gt; app-routes
             wrap-keyword-params
             wrap-json-params
             wrap-params))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hey. Hang on. There is no main method here, how can the java -jar command work without one ?
Well, because the ring plugin creates one for us.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint bash language-bash"><code>cat target classes/boot_sample/core/main.clj</code></pre>
</div>
</div>
<div class="paragraph">
<p>gives us</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>(do
  (clojure.core/ns boot-sample.core.main
   (:require ring.server.leiningen)
                   (:gen-class))
  (clojure.core/defn -main []
    (ring.server.leiningen/serve
     (quote {:ring {:auto-reload? false,
                    :stacktraces? false,
                    :open-browser? false,
                    :port 3360,
                    :handler boot-sample.core/app}}))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s useful to know in case boot-clj doesn&#8217;t happen to have a ring task that does something similar.</p>
</div>
</div>
<div class="sect2">
<h3 id="_boot_me_up">Boot me up</h3>
<div class="paragraph">
<p>Boot comes with a range of predefined tasks that I can compose to get quite close to the Leiningen build above.
I&#8217;ll focus on getting that uberjar up and running.</p>
</div>
<div class="paragraph">
<p>I could have done it all on the command line or in the boot repl, but lets just be a little declarative (still functions don&#8217;t worry!).</p>
</div>
<div class="paragraph">
<p>build.boot</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>(set-env!
 :resource-paths #{"src"}                                <b>(1)</b>
 :dependencies '[[org.clojure/clojure "1.6.0"]
                 [compojure "1.2.1"]
                 [liberator "0.12.2"]
                 [ring/ring-jetty-adapter "1.3.1"]
                 [ring/ring-json "0.3.1"]
                 [bouncer "0.3.1"]
                 [io.aviso/pretty "0.1.14"]])

(task-options!
 pom {:project 'boot-Sample
      :version "0.1.0"}
 aot {:namespace '#{boot-sample.core}}                  <b>(2)</b>
 jar {:main 'boot_sample.core                           <b>(3)</b>
      :manifest {"Description" "Sample boot app"
                 "Url" "https://github.com/rundis/boot-sample"}})


(deftask build
  "Build uberjar"
  []
  (comp (aot) (pom) (uber) (jar)))</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>To bundle your sources in the output jar, you have to specify src as a resource-path. A small gotcha there.</p>
</li>
<li>
<p>We need to aot our core.clj namespace so that java -jar can invoke it&#8217;s main method</p>
</li>
<li>
<p>We need to help java -jar with the location of our main class in the jar</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>However you might remember from above that there is no main method in core.clj.
So the last piece of the puzzle is to add one. It&#8217;t not that hard.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>(ns boot-sample.core
  (:require [ring.middleware.params :refer [wrap-params]]
            [ring.middleware.keyword-params :refer [wrap-keyword-params]]
            [ring.middleware.json :refer [wrap-json-params]]
            [compojure.core :refer [defroutes ANY GET]]
            [liberator.core :refer [defresource resource]]
            [ring.adapter.jetty :as jetty])                                <b>(1)</b>
  (:gen-class))                                                            <b>(2)</b>


;; ... the other stuff

(defn -main []
  (jetty/run-jetty app {:port 3360}))                                     <b>(3)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Using the jetty ring adapter</p>
</li>
<li>
<p>The :gen-class directive generates the necessary stuff for our main method to be invokable from java
during aot compilation</p>
</li>
<li>
<p>Fire away</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>At the time of writing there was a regression in boot that caused aot to fail.
I needed to build boot from source, should be fixed in the next release though.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint bash language-bash"><code>git clone git@github.com:boot-clj/boot.git
cd boot/boot/core
lein install</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now all is set to try it out:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint bash language-bash"><code>boot build
java -jar target/boot-sample-0.1.0.jar</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_all_is_well_then">All is well then ?</h3>
<div class="paragraph">
<p>Unfortunately not quite. For uberjar projects it seems boot-clj at the time of writing has some serious
performance challenges.</p>
</div>
<div class="ulist">
<div class="title">On my machine generating the uberjar takes:</div>
<ul>
<li>
<p>Leiningen : 12 seconds</p>
</li>
<li>
<p>boot-clj  : 46 seconds !</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It&#8217;s not like Leiningen is lightning fast in the first place. But for this scenario boot just doesn&#8217;t cut it.
I reported an <a href="https://github.com/boot-clj/boot/issues/94">issue</a> and got prompt responses from the developers
which can only be a good sign.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_concluding_remarks">Concluding remarks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>My initial question of whether or not I feel we could use boot for our current projects gets a thumbs down for now.</p>
</div>
<div class="paragraph">
<p>I think boot-clj carries a lot of promise and have some really great ideas. It&#8217;s going to be interesting to
see if boot-clj becomes a viable alternative to leiningen. I suppose a porting and/or interop story with lein
and lein plugins might be needed in addition to maturing both the model and obviously its performance characteristics.</p>
</div>
<div class="paragraph">
<p>I&#8217;m certainly keen on trying it out more. I might try out the clojurescript support next and maybe churn out some custom tasks
just for fun.</p>
</div>
</div>
</div></p>
  			<a href="/blog/2014/gr_lt_part5.html"><h1>A Groovy Light Table client - Step 5: Gradle dependencies in Light Table with dagre-D3</h1></a>
  			<p>18 June 2014</p>
        <p><em>Tags: </em>
		      <a href="/blog/tags/lighttable.html">lighttable</a>
	      
		      <a href="/blog/tags/groovy.html"> groovy</a>
	      
		      <a href="/blog/tags/clojurescript.html"> clojurescript</a>
	      
		      <a href="/blog/tags/gradle.html">gradle</a>
	      </p>
  			<p><div class="sect1">
<h2 id="_background">Background</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is the fifth post in my series "A Groovy Light Table client". A blog series about steps I take when trying to build a Groovy plugin for Light Table.</p>
</div>
<div class="sect2">
<h3 id="_tapping_more_into_the_potential_of_light_table">Tapping more into the Potential of Light Table</h3>
<div class="paragraph">
<p>So far the Groovy Light Table plugin hasn&#8217;t really showcased the real power of the Light Table Editor. What feature could showcase more of Light Table and at the same time prove useful in many scenarios ? For most projects I have worked on, the number of dependencies and their relationships have usually been non trivial. A couple of years back I wrote a post about showing gradle dependencies as a graphwiz png. Wouldn&#8217;t it be cool if I could show my gradle dependencies  inline in Light Table ? It would be even cooler if the graph was interactive and provided more/different value than the default dependency reporting you got from Gradle itself</p>
</div>
</div>
<div class="sect2">
<h3 id="_dagre_d3">dagre-D3</h3>
<div class="paragraph">
<p>So what library should I choose for laying out my planned dependency diagram ? My first instinct was something related to D3. However laying out a dot-graph sensibly on my own didn&#8217;t seem like a challenge I was quite up to. Luckily I found dagre-D3 and it looked to be just the thing I needed.  Of course I would have loved to have found something more clojurish and ideally something that supported an immediate mode ui (akin to Facebook React, but for graphing).  Maybe I didn&#8217;t look long or well enough but I couldn&#8217;t find anything obvious so I settled for <a href="https://github.com/cpettitt/dagre-d3">dagre-D3</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_gradle_dependencies">Gradle dependencies</h3>
<div class="paragraph">
<p>The second challenge I faced before even getting started was: How would I go about retrieving rich dependency information for my gradle projects using the tooling-api ? The information about dependencies default provided through the tooling api is fairly limited and wouldn&#8217;t have produced a very informative graph at all. Luckily I found through dialog with the Gradle guys that it should be possible to achieve what I wanted through a custom gradle model.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_it_s_all_about_the_data">It&#8217;s all about the data</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When I initially started developing the custom gradle model for retrieving dependency information I designed a data structure that resembled the dependency modelling in Gradle. However after prototyping with dagre and later trying to display multi project dependency graphs I decided to change the design. I ended up with a data structure more similar to that of a graph with nodes and edges.</p>
</div>
<div class="sect2">
<h3 id="_custom_gradle_model">Custom Gradle Model</h3>
<div class="paragraph">
<p>To create a Custom Gradle Model you need to create a Gradle Plugin. My plugin got the very informative name "Generic Gradle Model" (naming is hard!).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>class GenericGradleModelPlugin implements Plugin {
    final ToolingModelBuilderRegistry registry;

    @Inject
    public GenericGradleModelPlugin(ToolingModelBuilderRegistry registry) {
        this.registry = registry;
    }

    @Override
    void apply(Project project) {
        registry.register(new CustomToolingModelBuilder())
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The important bit above is registering my custom tooling builder to make it available to the tooling api !</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>private static class CustomToolingModelBuilder implements ToolingModelBuilder {

// .. other private methods left out for brevity

Map confDiGraph(Configuration conf) {
  def nodeTree = conf.allDependencies
    .findAll {it instanceof ProjectDependency}
    .collect {getProjectDepInfo(it as ProjectDependency)} +
    conf.resolvedConfiguration
        .firstLevelModuleDependencies
        .collect { getDependencyInfo(it) }

    def nodes = nodeTree.collect {collectNodeEntry(it)}.flatten().unique {nodeId(it)}
    def edges = nodeTree.collect {
      collectEdge(conf.name, it)
    }.flatten().unique()

    [nodes: nodes, edges: edges]
  }

  Map projectDeps(Project project) {
    [
      name: project.name,
      group: project.group,
      version: project.version,
      configurations: project.configurations.collectEntries{Configuration conf -&gt;
          [conf.name, confDiGraph(conf)]
      }
    ]
  }

  public boolean canBuild(String modelName) {
    modelName.equals(GenericModel.class.getName())
  }

  public Object buildAll(String modelName, Project project) {
    new DefaultGenericModel(
      rootDependencies: projectDeps(project),
      subprojectDependencies: project.subprojects.collect {projectDeps(it)}
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The custom tooling model builder harvests information about all dependencies for all defined configurations in the project. If the project is a multi-project It will collect the same information for each subproject in addition to collect information about interdependencies between the sub projects.</p>
</div>
</div>
<div class="sect2">
<h3 id="_applying_the_plugin_to_gradle_projects_we_connect_to">Applying the plugin to gradle projects we connect to</h3>
<div class="paragraph">
<p>Before we can retrieve our custom gradle model, we need to apply the plugin to the project in question. I could ask the users to do it themselves, but that wouldn&#8217;t be particularly user friendly.
Luckily Gradle provides init scripts that you can apply to projects and the tooling api supports doing so. Init scripts allows you to do&#8230; well &#8230; init stuff for your projects. Applying a plugin from the outside falls into that category.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>initscript {
  repositories {
    maven { url 'http://dl.bintray.com/rundis/maven' }
  }
  dependencies { classpath "no.rundis.gradle:generic-gradle-model:0.0.2" }
}

allprojects {
  apply plugin: org.gradle.tooling.model.generic.GenericGradleModelPlugin
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_retrieving_the_model">Retrieving the model</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>def genericModel = con.action(new GetGenericModelAction())
                            .withArguments("--init-script", new File("lib/lt-project-init.gradle").absolutePath)
                            .addProgressListener(listener)
                            .run()

private static class GetGenericModelAction implements Serializable, BuildAction {
  @Override
  GenericModel execute(BuildController controller) {
    controller.getModel(GenericModel)
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To retrieve the model we use a custom build action and applies the plugin implementing the custom model using the --init-script command line argument for gradle.</p>
</div>
<div class="paragraph">
<p>Voila we have the data we need and we return the dependency info (async) after you have connected to a gradle project.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_show_me_a_graph">Show me a graph</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The dependency graph and associated logic was separated out to a separate namespace (graph.cljs).
We&#8217;ll quickly run through some of the highlights of the LightTable clojurescript parts for displaying the dependency graph.</p>
</div>
<div class="sect2">
<h3 id="_graph_object">Graph object</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>(defui dependency-graph-ui [this]
  [:div.graph
   [:div.dependency-graph
    [:svg:svg {:width "650" :height "680"}
     [:svg:g {:transform "translate(20,20)"}]]]])

(object/object* ::dependency-graph
                :tags [:graph.dependency]
                :name "Dependency graph"
                :init (fn [this]
                        (load/js (files/join plugin-dir "js/d3.v3.min.js") :sync)
                        (load/js (files/join plugin-dir "js/dagre-d3.js") :sync)
                        (let [content (dependency-graph-ui this)]
                          content)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first step was to create and object that represents the view (and is able to hold the dependency data). The init method is responsible for loading the required graphing libs and then it creates the initial placeholder markup for the graph.</p>
</div>
</div>
<div class="sect2">
<h3 id="_some_behaviours">Some behaviours</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>(behavior ::on-dependencies-loaded
          :desc "Gradle dependencies loaded for selected project"
          :triggers #{:graph.set.dependencies}
          :reaction (fn [this rootDeps subDeps]
                      (object/merge! this {:rootDeps rootDeps
                                           :subDeps subDeps})))


(behavior ::on-show-dependencies
          :desc "Show dependency graph"
          :triggers #{:graph.show.dependencies}
          :reaction (fn [this root-deps]
                      (tabs/add-or-focus! dependency-graph)
                      (default-display this)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first behavior is triggered when the groovy backend has finished retrieving the project info, and more specifically the dependencies. If the project is a single project only the rootDeps will contain data.</p>
</div>
<div class="paragraph">
<p>The second behavior is triggered (by a command) when the user wishes to view the dependency graph for a connected gradle project.</p>
</div>
</div>
<div class="sect2">
<h3 id="_render_multiproject_graph_hightlighs">Render Multiproject graph Hightlighs</h3>
<div class="paragraph">
<p>For multi projects the plugin renders an overview graph where you can see the interdependencies between you sub projects.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>(defn create-multiproject-graph [this]
  (let [g (new dagreD3/Digraph)]
    (doseq [x (:nodes (multi-proj-deps this))]
      (.addNode g (dep-id x) #js {:label (str "&lt;div class='graph-label clickable' data-proj-name='"
                                              (:name x) "' title='"
                                              (dep-id x) "'&gt;"
                                              (:name x) "&lt;br/&gt;"
                                              (:version x)
                                              "&lt;/div&gt;")}))
    (doseq [x (:edges (multi-proj-deps this))]
      (.addEdge g nil (:a x) (:b x) #js {:label ""}))
    g))

(defn render-multi-deps [this]
  (let [renderer (new dagreD3/Renderer)
        g (dom/$ :g (:content @this))
        svg (dom/$ :svg (:content @this))
        layout (.run renderer (create-multiproject-graph this) (d3-sel g))
        dim (dimensions this)]
    (unbind-select-project this)
    (bind-select-project this)
    (.attr (d3-sel svg) "width" (+ (:w dim) 20))
    (.attr (d3-sel svg) "height" (+ (:h dim) 20))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first function shows how we use dagre-D3 to create a logical dot graph representation. We basically add nodes and edges (dep&#8594;dep). Most of the code is related to what&#8217;s rendered inside each node.</p>
</div>
<div class="paragraph">
<p>The second function shows how we actually layout and display the graph.  In addition we bind click handlers to our custom divs inside the nodes. The click handlers allows for drill down into a detailed graph about each dependency configuration.</p>
</div>
</div>
<div class="sect2">
<h3 id="_end_results">End results</h3>
<div class="imageblock">
<div class="content">
<img src="/blog/2014/ratpack_multi.png" alt="ratpack multi">
</div>
<div class="title">Figure 1. Multiproject sample : Ratpack</div>
</div>
<div class="imageblock">
<div class="content">
<img src="/blog/2014/ratpack_reactor.png" alt="ratpack reactor">
</div>
<div class="title">Figure 2. Project configuration dependencies</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I think we achieved some pretty cool things. Maybe not a feature that you need everyday, but its certainly useful to get an overview of your project dependencies. For troubleshooting transitive dependency issues and resolution conflicts etc you might need more details though.</p>
</div>
<div class="paragraph">
<p>We have certainly showcased that you can do some really cool things with Light Table that you probably wouldn&#8217;t typically do (easily) with a lot of other editors and IDE&#8217;s. We have also dug deeper into the gradle tooling api. The gradle tooling api when maturing even more will provide some really cool new options for  JVM IDE integrations. A smart move by gradleware that opens up for integrations from a range of editors, IDE&#8217;s and specialised tools and applications.</p>
</div>
<div class="paragraph">
<p>The end result of the dependency graph integration became the largest chunk of the 0.0.6 release.</p>
</div>
</div>
</div></p>
  			<a href="/blog/2014/gr_lt_part4.html"><h1>A Groovy Light Table client - Step 4: Exploring new avenues with Gradle</h1></a>
  			<p>26 May 2014</p>
        <p><em>Tags: </em>
		      <a href="/blog/tags/lighttable.html">lighttable</a>
	      
		      <a href="/blog/tags/groovy.html"> groovy</a>
	      
		      <a href="/blog/tags/gradle.html"> gradle</a>
	      
		      <a href="/blog/tags/clojurescript.html"> clojurescript</a>
	      </p>
  			<p><div class="sect1">
<h2 id="_background">Background</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is the fourth post in my series "A Groovy Light Table client". A blog series about steps I take when trying to build a Groovy plugin for Light Table.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_initial_ponderings">Initial ponderings</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gradle ships with a Tooling API that makes it fairly easily to integrate with your Gradle projects. Initially I thought that Gradle integration should be a separate plugin that other jvm language plugins could depend on, starting with the Groovy plugin. However after much deliberation I decided to start out with bundling the gradle integration with the Groovy plugin. There is certainly a degree of selecting the easy option to that decision. However I still consider the integration exploratory and I&#8217;m not sure how it will pan out. I&#8217;ve settled for a strategy of keeping it logically fairly separate, with a mind to separating gradle specifics out to its own plugin when things become clearer.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_classpath_integration_for_groovy_repl">Classpath Integration for Groovy "REPL"</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In part 3 I talked about some REPL like features where variables that result in bindings are stored in a editor session and used as input to the next evaluation. Since then I&#8217;ve also added the feature of caching method definitions (albeit as closures so I&#8217;m sure there are gotchas to that approach as well).</p>
</div>
<div class="paragraph">
<p>Anyways wouldn&#8217;t it be nice If I could also explore my project classes and my projects third party library dependencies in a REPL like fashion ? Hence the idea of providing a Gradle integration. With the Tooling API I should be able to retrieve a class path. So this is where i started.
Before anyone potentially asking; I will not bother with maven or ant at any point in time, I&#8217;ll leave that to someone else.</p>
</div>
<div class="sect2">
<h3 id="_retrieving_the_class_path_as_a_list_from_a_gradle_project">Retrieving the class path as a list from a Gradle project</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>// Step 1: Connecting to project
def con = GradleConnector.newConnector()
  .forProjectDirectory(projectDir)
  .connect()

// Step 2: Get hold of a project model, for now a IdeaModel provides what we need
def ideaProject = con.model(IdeaProject)
  .addProgressListener(listener)
  .get()

// Step 3: Get list of dependencies
def deps = ideaProject.children
  .dependencies
  .flatten()
  .findAll { it.scope.scope == "COMPILE" }
  .collect {
    [
      name   : it.gradleModuleVersion?.name,
      group  : it.gradleModuleVersion?.group,
      version: it.gradleModuleVersion?.version,
      file   : it.file?.path,
      source : it.source?.path,
      javadoc: it.javadoc?.path
    ]
  }

def classpathList = deps.file + [new File(projectDir, "build/classes/main").path]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above code is actually wrapped in a class. Connection and model instances are cached for performance reasons.
We connect to our gradle project. If the project ships with a gradle wrapper (which it should IMO), the gradle connector will use that version (download the distribution even if need be). Otherwise it will use the gradle version of the tooling-api. At the time of writing that&#8217;s 1.12
The tooling api doesn&#8217;t really expose as much information by default as you might wish. However it ships with an IdeaModel and an EclipseModel that provides what we need for the purposes of creating a class path. As an Idea user the IdeaModel seemed the right choice ! There is also added a progress listener, which is a callback from the api reporting progress. The progress listener returns each progress event as a string to Light Table so that we can display progress information
We basically navigate the model and extract information about dependencies and put it in a list of maps for ease of jsonifying (useful later !). The location of our projects custom compiled classes are added manually to the class path list (ideally should have been retrieved from the model as well&#8230;)
Adding the class path list to our groovy shell before code invocation</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>private GroovyShell createShell(Map params) {
def transform = new ScriptTransform()
def conf = new CompilerConfiguration()
  conf.addCompilationCustomizers(new ASTTransformationCustomizer(transform))
  conf.addCompilationCustomizers(ic)

  if(params.classPathList) {
    conf.setClasspathList(params.classPathList)
  }

  new GroovyShell(conf)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Its basically just a matter of adding the class path list to the CompilerConfiguration we initialise our GroovyShell with. Sweet !
Voila your groovy scripts can invoke any class in your project?s class path.</p>
</div>
<div class="paragraph">
<p>This addition basically resulted in version 0.0.4</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reporting_progress">Reporting progress</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_groovy">Groovy</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>class ProgressReporter implements LTProgressReporter {
    final LTConnection ltCon

    ProgressReporter(LTConnection ltCon) { this.ltCon = ltCon }

    @Override
    void statusChanged(ProgressEvent event) {
        if (event.description?.trim()) {
            reportProgress(event.description)
        }
    }

    void reportProgress(String message) {
        ltCon.sendData([null, "gradle.progress",[msg: message]])
    }
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Notes</div>
<ul>
<li>
<p>statusChanges is called by gradle (LTProgressReporter extends the Gradle ProgressListener interface)</p>
</li>
<li>
<p>reportProgress sends the progress information to Light Table</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_light_table">Light Table</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>(behavior ::on-gradle-progress
  :desc "Reporting of progress from gradle related tasks"
  :triggers #{:gradle.progress}
  :reaction (fn [this info]
              (notifos/msg* (str "Gradle progress: " (:msg info)) {:timeout 5000})))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The progress behaviour just prints a message to the Light Table status bar.</p>
</div>
</div>
<div class="sect2">
<h3 id="_executing_gradle_tasks">Executing Gradle Tasks</h3>
<div class="paragraph">
<p>There are two parts to this puzzle. One is to retrieve information about what tasks are actually available for the given project. The other is to actually invoke the task (tasks in the future).
Listing tasks Groovy/Server</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code> // Step 1: Retrieve generic Gradle model
def gradleProject = con.model(GradleProject)
  .addProgressListener(listener)
  .get()

// Step 2: Get list of available tasks
gradleProject.tasks.collect{
  [
    name: it.name,
    displayName: it.displayName,
    description: it.description,
    path: it.path
  ]
}

// Step 3: Send task list to client (omitted, you get the general idea by now !)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_listing_tasks_in_light_table">Listing tasks in Light Table</h3>
<div class="paragraph">
<p>The list of tasks is actually retrieved by the Light Table plugin once you select to connect to a gradle project. Furthermore the list is cached in an atom.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>(behavior ::on-gradle-projectinfo
  :desc "Gradle project model information"
  :triggers #{:gradle.projectinfo}
  :reaction (fn [this info]
              (object/merge! groovy {::gradle-project-info info})
              (object/assoc-in! cmd/manager [:commands :gradle.task.select :options] (add-selector))))
</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the groovy server has finished retrieving the tasks (and other project info) the above behaviour is triggered in Light Table:</p>
</div>
<div class="paragraph">
<p>We store the project info in our Groovy object (an atom)
We also update the command for selecting tasks with the new list of tasks. See the section below for details.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>(behavior ::set-selected
  :triggers #{:select}
  :reaction (fn [this v]
              (scmd/exec-active! v)))

(defn selector [opts]
  (doto (scmd/filter-list opts)
    (object/add-behavior! ::set-selected)))

(defn get-tasks []
  (-&gt;@groovy ::gradle-project-info :tasks))

(defn add-selector []
  (selector {:items (get-tasks)
             :key :name
             :transform #(str "&lt;p&gt;" (:name %4) "&lt;/p&gt;"
                              "&lt;p class='binding'&gt;" (:description %4) "&lt;/p&gt;")}))

(cmd/command {:command :gradle.task.select
              :desc "Groovy: Select Gradle task"
              :options (add-selector)
              :exec (fn [item]
                      (object/raise groovy :gradle.execute item))})
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above code adds a sub panel to the default sidebar command panel. When you select the command :gradle.task.select it will show a child panel listing the tasks from the get-tasks function.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/blog/2014/lt_gr_tasks.png" alt="lt gr tasks">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>;; Behavior to actually trigger execution of a selected task from the list above
(behavior ::on-gradle-execute
  :desc "Gradle execute task(s)"
  :triggers #{:gradle.execute}
  :reaction (fn [this task]
              (clients/send
                (clients/by-name "Groovy")
                :gradle.execute
                {:tasks [(:name task)]})))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once you have selected a task the above behaviour is triggered. We get hold of an editor agnostic groovy client and send an execute task message with a list of task (currently always just one). The data we send will be extended in the future to support multiple tasks and build arguments.</p>
</div>
<div class="paragraph">
<p>Server side Task execution</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>// Generic execute task function
def execute(Map params, Closure onComplete) {
    def resultHandler = [
        onComplete: {Object result -&gt;
            onComplete status: "OK"
        },
        onFailure: {GradleConnectionException failure -&gt;
            onComplete status: "ERROR", error: failure
        }
    ] as ResultHandler


    con.newBuild()
    .addProgressListener(listener)
    .forTasks(params.tasks as String[])
    .run(resultHandler)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we use the asynch features of the Gradle Tooling API. Executing a task may actually take a while so it certainly makes sense. Callers of the execute method will receive a callback (onComplete) once task execution is completed successfully (of failed).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>projectConnection.execute(params) {Map result -&gt;
    ltConnection.sendData([
        null,
        result.status == "ERROR" ? "gradle.execute.err" : "gradle.execute.success",
        result
    ])
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We invoke the execute method with a closure argument and return the results (success/failure) back to Light Table.</p>
</div>
<div class="paragraph">
<p>This brings us pretty much up to version 0.0.5</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_summary">Summary</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Well we covered a lot of ground here. We can now call any class that&#8217;s in your Gradle project&#8217;s class path from a groovy editor in Light Table. We&#8217;ve also started on providing Gradle features that are language agnostic. Starting with support for listing and executing tasks in your gradle project.
We&#8217;ve added decent progress reporting and performance seems to be pretty good too. Looks like we have something we can build further upon !</p>
</div>
<div class="paragraph">
<p>I have lots of ideas; Infinitesting,  single test with inline results, compile single file, grails integration ? etc etc. I also really want to show project dependencies in a graph. However before I can do any of those things I need to extend the tooling api with custom models &#8230; and/or maybe I should see if I can contribute to the gradle project in extending the tooling-api with a richer generic project model.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll have to wait and see. Next week I&#8217;m off to gr8conf.eu in Copenhagen. Really looking forward to meeting up with all the great Groovy dudes/dudettes.  And who knows maybe the hackergarten evening will result in something new and exciting !</p>
</div>
</div>
</div></p>
  			<a href="/blog/2014/groovy_repl.html"><h1>Groovy Light Table Plugin</h1></a>
  			<p>19 May 2014</p>
        <p><em>Tags: </em>
		      <a href="/blog/tags/lighttable.html">lighttable</a>
	      
		      <a href="/blog/tags/clojurescript.html"> clojurescript</a>
	      
		      <a href="/blog/tags/groovy.html"> groovy</a>
	      
		      <a href="/blog/tags/screencast.html"> screencast</a>
	      </p>
  			<p><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>A short demonstration of the repl like capabilities of my Light Table Groovy plugin (<a href="https://github.com/rundis/LightTable-Groovy">https://github.com/rundis/LightTable-Groovy</a>)</p>
</div>
<iframe width="560" height="315" src="http://www.youtube.com/embed/5ji8RR2A4gQ" frameborder="0" allowfullscreen></iframe>
</div>
</div></p>
  			<a href="/blog/2014/gr_lt_part3.html"><h1>A Groovy Light Table client - Step 3: Running out of quick wins</h1></a>
  			<p>12 May 2014</p>
        <p><em>Tags: </em>
		      <a href="/blog/tags/lighttable.html">lighttable</a>
	      
		      <a href="/blog/tags/groovy.html"> groovy</a>
	      
		      <a href="/blog/tags/clojurescript.html"> clojurescript</a>
	      </p>
  			<p><div class="sect1">
<h2 id="_background">Background</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is the third post in my series "A Groovy Light Table client". A blog series about steps I take when trying to build a Groovy plugin for Light Table.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_running_out_of_quick_wins">Running out of quick wins</h2>
<div class="sectionbody">
<div class="paragraph">
<p>After 0.0.2 of the plugin was released I was pretty happy. I had something that I could actually use as an alternative Groovy Console. However I was keen to keep up the flow so I figured I would try to implement an autocomplete feature. The task proved rather daunting. Not so much from the Light Table side of things, but rather from the Groovy side. First I tried to see if I could reuse anything from GroovySh, but that didn&#8217;t look to promising. After that I tried to get my head around whether I could somehow reuse something from IntelliJ or Eclipse. I failed to see the light so I gave up that endeavour. Secondly I tried to see if there was an easy way to provide an inline documentation feature. Sadly I couldn&#8217;t find much reusable and something with a small foot print here either. Someone should make a REST based doc search feature for Groovy Docs one day !</p>
</div>
<div class="paragraph">
<p>I turned my attention to a couple of other plugins that I thought would be useful for Light Table. I created a Buster.JS plugin <a href="https://github.com/busterjs/lt-instabuster">InstaBuster</a> for easily running JavaScript tests. I also created a snippets/code templates plugin <a href="https://github.com/rundis/lt-snippets">lt-snippets</a> and some snippet collections, among them a small collection of <a href="https://github.com/rundis/lt-groovy-snippets">groovy snippets</a>.</p>
</div>
<div class="paragraph">
<p>There is just no way I could ever compete with the mainstream IDE&#8217;s, but then again that was never really the original intention. But even with limited capacity it should still be possible to provide useful groovy support and maybe even something fairly unique within the super hackable framework of Light Table.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_small_step_towards_a_groovy_repl">A (small) step towards a Groovy REPL</h2>
<div class="sectionbody">
<div class="paragraph">
<p>After working with Light Table and the Clojure/ClojureScript REPL I have grown very fond of that exploratory nature of working. Is there anything I could do with the plugin to give a more REPL like feel ? Well a small but helpful step would be to be able to remember what I previously have evaluated &#8230;</p>
</div>
<div class="sect2">
<h3 id="_groovy_bindings">Groovy Bindings</h3>
<div class="paragraph">
<p>A simple but still useful mechanism would be to cache bindings from script execution between evals.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>// from the evalGroovy method
def evalResult = scriptExecutor.execute(data.code, clientSessions.get(currentClientId))
clientSessions.put(currentClientId, evalResult.bindings)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each editor in Light Table gets it&#8217;s own unique Id. So I just created a simple cache "ClientSessions" that hold a map of binding variables, mapped my that Id. When executing a script the current binding variables are applied to the script and after the script has executed the resulting binding variables are added/replaced in the cache. Dead simple really.</p>
</div>
</div>
<div class="sect2">
<h3 id="_clearing_bindings_light_table">Clearing bindings - Light Table</h3>
<div class="paragraph">
<p>I figured it would be handy to be able to clear any stored bindings. So a new command and behaviour was created in Light Table</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>;; Behavior for clearing bindings
(behavior ::on-clear-bindings
          :desc "Clear cached bindings for this editor"
          :triggers #{:on.clear.bindings}
          :reaction (fn [editor]
                      (let [info (:info @editor)
                            cl (eval/get-client! {:command :editor.clear.groovy
                                                    :origin editor
                                                    :info info
                                                    :create try-connect})]
                          (clients/send cl
                                        :editor.clear.groovy info
                                        :only editor))))

;; Command that allows a new keyboard bindable action for invoking the behaviour above
(cmd/command {:command :clear-bindings
              :desc "Groovy: Clear bindings for current editor"
              :exec (fn []
                      (when-let [ed (pool/last-active)]
                        (object/raise ed :on.clear.bindings)))})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The command retrieves the currently active editor and triggers the behaviour. The behaviour retrieves a client connection (or creates one if one shouldn&#8217;t exist) and calls the server (groovy).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>// Wiring up the behaviour in groovy.behaviors
:editor.groovy [:lt.plugins.groovy/on-eval
                     :lt.plugins.groovy/on-eval.one
                     :lt.plugins.groovy/on-clear-bindings
                     :lt.plugins.groovy/groovy-res
                     :lt.plugins.groovy/groovy-err
                     [:lt.object/add-tag :watchable]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The final piece of the puzzle from the Light Table side is to attach the behavior to the :editor.groovy tag. This enables the behavior to be available from any editor that is tagged with this tag.</p>
</div>
</div>
<div class="sect2">
<h3 id="_clearing_bindings_groovy">Clearing bindings - Groovy</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>// The command dispatch got a new command
case "editor.clear.groovy":
   clientSessions.clear(currentClientId)
   break;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code above will just nuke any stored binding variables.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusions">Conclusions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A tiny step that allows you to eval groovy expressions step by step. Anything that results in a binding is stored between evals. Obviously it&#8217;s a bit limited in that you&#8217;ll run into the familiar trap of trying to use def and be surprised(/annoyed) that it won&#8217;t remember that or if you define a class it won&#8217;t remember that either. It&#8217;s probably possible to cater for some of these traps, but maybe not within the realms of a quick win.</p>
</div>
<div class="paragraph">
<p>Anyways the end result is Version 0.0.3 !</p>
</div>
<div class="paragraph">
<p>Next steps</p>
</div>
<div class="paragraph">
<p>Firstly there is a Screencast brewing. After that I think a Light Table Gradle plugin is coming before the Groovy plugin gets any further updates. A pluggable Gradle plugin would enable the Groovy plugin to quite easily get the class path for you project. This would allow you to  explore your projects code in a REPL (-like) way. Exploratory testing FTW !</p>
</div>
</div>
</div></p>
  			<a href="/blog/2014/lt-snippets.html"><h1>Creating and using snippets in Light Table</h1></a>
  			<p>06 May 2014</p>
        <p><em>Tags: </em>
		      <a href="/blog/tags/lighttable.html">lighttable</a>
	      
		      <a href="/blog/tags/plugin.html"> plugin</a>
	      
		      <a href="/blog/tags/clojure.html"> clojure</a>
	      
		      <a href="/blog/tags/clojurescript.html"> clojurescript</a>
	      
		      <a href="/blog/tags/screencast.html"> screencast</a>
	      </p>
  			<p><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>A short introduction to my Light Table Snippets plugin (<a href="https://github.com/rundis/lt-snippets">https://github.com/rundis/lt-snippets</a>).</p>
</div>
<iframe width="560" height="315" src="http://www.youtube.com/embed/I6iuXOw3HDQ" frameborder="0" allowfullscreen></iframe>
</div>
</div></p>
  			<a href="/blog/2014/instabuster_part2.html"><h1>JavaScript testing with Light Table and Buster.JS</h1></a>
  			<p>21 April 2014</p>
        <p><em>Tags: </em>
		      <a href="/blog/tags/lighttable.html">lighttable</a>
	      
		      <a href="/blog/tags/clojurescript.html"> clojurescript</a>
	      
		      <a href="/blog/tags/javascript.html"> javascript</a>
	      
		      <a href="/blog/tags/screencast.html"> screencast</a>
	      </p>
  			<p><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Second part of the intro to the Light Table Buster plugin (<a href="https://github.com/busterjs/lt-instabuster">https://github.com/busterjs/lt-instabuster</a>)
This time demonstrating some of the more advanced features.</p>
</div>
<iframe width="560" height="315" src="http://www.youtube.com/embed/jYDiAVbPL8I" frameborder="0" allowfullscreen></iframe>
</div>
</div></p>
  			<a href="/blog/2014/instabuster_part1.html"><h1>JavaScript testing with Light Table and Buster.JS</h1></a>
  			<p>17 March 2014</p>
        <p><em>Tags: </em>
		      <a href="/blog/tags/lighttable.html">lighttable</a>
	      
		      <a href="/blog/tags/clojurescript.html"> clojurescript</a>
	      
		      <a href="/blog/tags/javascript.html"> javascript</a>
	      
		      <a href="/blog/tags/screencast.html"> screencast</a>
	      </p>
  			<p><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Intro to the Light Table Buster plugin (<a href="https://github.com/busterjs/lt-instabuster">https://github.com/busterjs/lt-instabuster</a>)</p>
</div>
<iframe width="560" height="315" src="http://www.youtube.com/embed/WKHWazblpbc" frameborder="0" allowfullscreen></iframe>
</div>
</div></p>
  			<a href="/blog/2014/gr_lt_part2.html"><h1>A Groovy Light Table client - Step 2: Evaluating Code</h1></a>
  			<p>23 February 2014</p>
        <p><em>Tags: </em>
		      <a href="/blog/tags/lighttable.html">lighttable</a>
	      
		      <a href="/blog/tags/groovy.html"> groovy</a>
	      
		      <a href="/blog/tags/clojurescript.html"> clojurescript</a>
	      </p>
  			<p><div class="sect1">
<h2 id="_background">Background</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is the second post in my series "A Groovy Light Table client". A blog series about steps I take when trying to build a Groovy plugin for Light Table.</p>
</div>
<div class="paragraph">
<p>In this post I will take you through some of the steps I went through to get Light Table to evaluate groovy (script) code and show results inline in the editor.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/blog/2014/lt_groovy_eval.png" alt="lt groovy eval">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_did_we_get_here">How did we get here ?</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_evaluate_contents_of_editor_cmd_ctrl_shift_enter">Evaluate contents of editor (cmd/ctrl + shift + enter)</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>(behavior ::on-eval
          :desc "Groovy: Eval current editor"
          :triggers #{:eval}
          :reaction (fn [editor]
                      (object/raise groovy :eval! {:origin editor
                                                   :info (assoc (@editor :info)
                                                           :code (ed/-&gt;val editor)
                                                           :meta {:start 0, :end (ed/last-line editor)})})))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This behavior triggers on ":eval", which is triggered to any editor (on cmd/ctrl + shift + enter in default key mapping). We just get hold of the text from the editor and gather some meta info  and trigger a ":eval!" behavior on the groovy "mother" object defined in the previous blog post.</p>
</div>
</div>
<div class="sect2">
<h3 id="_evaluate_current_line_selection">Evaluate current line/selection</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>(behavior ::on-eval.one
          :desc "Groovy: Eval current selection"
          :triggers #{:eval.one}
          :reaction (fn [editor]
                      (let [pos (ed/-&gt;cursor editor)
                            info (conj (:info @editor)
                                  (if (ed/selection? editor)
                                    {:code (ed/selection editor) :meta {:start (-&gt; (ed/-&gt;cursor editor "start") :line)
                                                                        :end (-&gt; (ed/-&gt;cursor editor "end") :line)}}
                                    {:pos pos :code (ed/line editor (:line pos)) :meta {:start (:line pos) :end (:line pos)}}))]
                        (object/raise groovy :eval! {:origin editor :info info}))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The only difference here is that we gather the code for the current line or current selection. Then we trigger the same behavior as for evaluating the whole editor.</p>
</div>
</div>
<div class="sect2">
<h3 id="_our_groovy_eval">Our groovy Eval!</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>(behavior ::eval!
          :triggers #{:eval!}
          :reaction (fn [this event]
                      (let [{:keys [info origin]} event
                            client (-&gt; @origin :client :default)]
                        (notifos/working "Evaluating groovy...")
                        (clients/send (eval/get-client! {:command :editor.eval.groovy
                                                         :origin origin
                                                         :info info
                                                         :create try-connect})
                                      :editor.eval.groovy info
                                      :only origin))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This behavior is what actually sends off a eval request to the groovy client. Quite a lot happens under the hood (by help of inbuilt LightTable behaviors):</p>
</div>
<div class="paragraph">
<p>It tries to find a client (connection) for the editor
If no connection exists it will try to create a new one. On create it will invoke the try-connect function that we defined for the gui connect/connect bar behavior in the previous blog post
Once connected it will jsonify our parameters and send them off to our groovy client</p>
</div>
<div class="listingblock">
<div class="title">The JSON might look something like:</div>
<div class="content">
<pre class="prettyprint javascript language-javascript"><code>[89,
"editor.eval.groovy",
  {"line-ending":"\n",
   "name":"sample.groovy",
   "type-name":"Groovy",
   "path":"/Users/mrundberget/Library/Application Support/LightTable/plugins/Groovy/sample.groovy",
   "mime":"text/x-groovy",
   "tags":["editor.groovy"],
   "code":"println \"hello\"",
   "meta":{"start":22,"end":22}}]</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Notes</div>
<ul>
<li>
<p>The first param is the client id for the editor that triggered the behavior. This client Id doesn&#8217;t represent the same as a connection id (ref previous blog post). Many editors may share the same connection !</p>
</li>
<li>
<p>The second param is the command (our groovy client will of course support many different commands, this is one of them)</p>
</li>
<li>
<p>The third and last parameter is our info. The code is the essential bit, but some of the meta information, like line info comes in handy when handling the response later on</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_the_actual_groovy_evaluation">The actual groovy evaluation</h3>
<div class="sect3">
<h4 id="_command_dispatch">Command dispatch</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>ltClient.withStreams { input, output -&gt;
  try {
    input.eachLine { line -&gt;
    def (currentClientId, command, data) = new JsonSlurper().parseText(line)
    switch (command) {
    case "client.close":
      stop()
      break
    case "editor.eval.groovy":
      evalGroovy(data, currentClientId)
      break
   default:
     log "Invalid command: $command"
  }
  // ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>We parse any lines received from Light Table and based on the command received invokes the appropriate handler. In this case evalGroovy.</p>
</div>
</div>
<div class="sect3">
<h4 id="_eval_groovy">Eval groovy</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>private void evalGroovy(data, currentClientId) {
  def evalResult = scriptExecutor.execute(data.code)

  def resultParams = [meta: data.meta]
  if (evalResult.out) {
    resultParams &lt;&lt; [out: evalResult.out]
  }
  if(evalResult.exprValues) {
    resultParams &lt;&lt; [result: convertToClientVals(evalResult.exprValues)]
  }

  if (!evalResult.err) {
    data = [currentClientId?.toInteger(), "groovy.res", resultParams]
  } else {
    data = [currentClientId?.toInteger(), "groovy.err", [ex: evalResult.err] + resultParams]
  }
  sendData data
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first and most significant line is where we evaluate the groovy code received. This post would be too long if we went into all the details of what it does, but here&#8217;s a high-level summary:</p>
</div>
<div class="paragraph">
<p>We basically create a GroovyShell and compile our code to a script. Normally that would just compile a Script class. However we  wish to collect a lot more information than you typically would get from default groovy script execution. So we do an AST transformation on the script class and add a custom abstract script class as a base class for the compiled script class.  This allows us to inject behavior and wrap statement execution (all compiled into the script for optimal performance).  That way we are able to collect information about values for most types of statements. We collect line number and value (each line could end up having many values :-) )
We run the script (capturing system.out and system.err).</p>
</div>
<div class="ulist">
<div class="title">The function returns:</div>
<ul>
<li>
<p>Anything written to standard out (println etc)</p>
</li>
<li>
<p>Errors if any and line number for error where possible</p>
</li>
<li>
<p>A list for of maps with line number and value(s)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Most of the AST stuff is not something I&#8217;ve written. It&#8217;s been contributed by Jim White after I posted a question on the groovy-user mailing list. I asked for advice on which way to proceed and the response from the groovy community was awesome. Jim in particular was more than eager to contribute to the plugin. OpenSource rocks ! So when I say we, I sometimes mean we literally.</p>
</div>
<div class="paragraph">
<p>Anyways, based on the results of the script execution we notify Light Table to trigger either a ":groovy.res" behavior or a "groovy.err" behavior.</p>
</div>
<div class="paragraph">
<p>The json response for sendData for a successful execution might look something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint javascript language-javascript"><code>[89,
 "groovy.res",
 {"meta":{"start":22,"end":23},"out":"hello\nmama\n","result":[{"line":1,"values":["null"]},{"line":2,"values":["null"]}]}]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_handling_the_evaluation_results_in_light_table">Handling the evaluation results in Light Table</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>(defn notify-of-results [editor res]
  (doseq [ln (:result res)]
    (let [lineNo (+ (:line ln) (-&gt; res :meta :start) -1)]
      (object/raise editor :editor.result (clojure.string/join " " (:values ln)) {:line lineNo :start-line lineNo}))))

(behavior ::groovy-res
          :triggers #{:groovy.res}
          :reaction (fn [editor res]
                      (notifos/done-working)
                      (when-let [o (:out res)] (.log js/console o))
                      (notify-of-results editor res)))

(defn notify-of-error [editor res]
  (let [lineNo (+ (-&gt; res :ex :line) (-&gt; res :meta :start) -1)]
    (object/raise editor :editor.exception (:ex res) {:line lineNo :start-line lineNo'})))

(behavior ::groovy-err
          :triggers #{:groovy.err}
          :reaction (fn [editor res]
                      (object/raise editor :groovy.res res)
                      (notify-of-error editor res)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>These are the behavior definitions that handles either successful or evaluation of scripts with errors. Basically we:
Print to the Light Table Console anything that was captured to system.out/system.err by our groovy evaluation
Show inline results for each line, multiple results for a line are space separated. For showing inline results we are using a predefined Light Table behavior (:editor.result)
If the behavior is to handle an error, we show evaluation results up until the script exception. In addition we display details (stack trace) for the exception at the line in the script it occurred</p>
</div>
</div>
<div class="sect2">
<h3 id="_wiring_it_all_up">Wiring it all up</h3>
<div class="sect3">
<h4 id="_groovy_behaviors">groovy.behaviors</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>{:+ {:app [(:lt.objs.plugins/load-js ["codemirror/groovy.js", "groovy_compiled.js"])]
     :clients []
     :editor.groovy [:lt.plugins.groovy/on-eval
                     :lt.plugins.groovy/on-eval.one
                     :lt.plugins.groovy/groovy-res
                     :lt.plugins.groovy/groovy-err
                     [:lt.object/add-tag :watchable]]
     :files [(:lt.objs.files/file-types
              [{:name "Groovy" :exts [:groovy] :mime "text/x-groovy" :tags [:editor.groovy]}])]
     :groovy.lang [:lt.plugins.groovy/eval!
                   :lt.plugins.groovy/connect]}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The eval and results/err behaviors are defined for the editor tag. So they are only applicable for editors marked as groovy editors. Any editor open with a file name ending in .groovy will automatically be attached to a editor.groovy tag. (You can also set it manually cmd+space &#8594; "Editor: Set current editor syntax").
The ":eval!" behavior is defined for the :groovy.lang tag. Its tied to our groovy mother object just like the connect behavior. These behaviors are totally groovy client specific, whilst the other behaviors are less so (although not exactly generic as they are now?)</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_wrap_up">Wrap up</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A little bit of plumbing was needed to get this set up. But the hard parts was really coming up with the groovy AST transformation stuff. I guess by now you might have started getting an inkling that Light Table is fairly composable ? It really is super flexible. You don&#8217;t like the behavior for handling inline results for the groovy plugin ? You could easily write your own and wire it up in your user.behaviors file in Light Table. It&#8217;s wicked cool, actually it really is your editor !</p>
</div>
<div class="paragraph">
<p>Yesterday I released version 0.0.2 of the Groovy LightTable plugin. Its available through the Light Table plugin manager, or if you wish to play with the code or maybe feel like contributing feel free to fork the repo at : <a href="https://github.com/rundis/LightTable-Groovy">https://github.com/rundis/LightTable-Groovy</a>. Pull requests are welcome.</p>
</div>
<div class="paragraph">
<p>So where to next ? I&#8217;d really like to try and create an InstaRepl editor for the plugin. A groovy script editor that evaluates code as you type. There&#8217;s gotta be one or two challenges related to that. A quick win might be to provide groovy api documentation from inside Light Table. I&#8217;ll let you know what happens in the next post.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Disclaimer: I might have misunderstood some nuances of Light Table, but hopefully I&#8217;m roughly on track. If you see anything glaringly wrong, do let me know.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div></p>
  			<a href="/blog/2014/gr_lt_part1.html"><h1>A Groovy Light Table client - Step 1: Connecting the client</h1></a>
  			<p>16 February 2014</p>
        <p><em>Tags: </em>
		      <a href="/blog/tags/lighttable.html">lighttable</a>
	      
		      <a href="/blog/tags/groovy.html"> groovy</a>
	      
		      <a href="/blog/tags/clojurescript.html"> clojurescript</a>
	      </p>
  			<p><div class="sect1">
<h2 id="_building_a_plugin_in_light_table">Building a plugin in Light Table</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is the first post in (hopefully) a series of blog posts about the various steps I go through when trying to create a plugin for Light Table. I have decided to try to create a Groovy plugin. I chose Groovy to ensure there was at least one technology fairly familiar to me. I have just started using Light Table, I have no previous experience with ClojureScript and I have just recently started writing some Clojure beyond the basic tutorials.</p>
</div>
<div class="paragraph">
<p>The short term goal is for the plugin to provide inline results and maybe an instarepl of some sort for groovy scripts.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/rundis/LightTable-Groovy">LightTable-Groovy</a> is the name of my plugin project and you can find the latest source there. It might be a couple of steps ahead of the blog posts though !</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_documentation">Documentation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Light Table was made <a href="http://www.chris-granger.com/2014/01/07/light-table-is-open-source/">open source</a> in january and documentation for plugin developers is a little sparse.</p>
</div>
<div class="ulist">
<div class="title">So to have something to go by I decided to use some of the other language plugins as inspiration:</div>
<ul>
<li>
<p><a href="https://github.com/LightTable/Python">Python plugin</a> (comes bundled/under the light table umbrella)</p>
</li>
<li>
<p><a href="https://github.com/existentialmutt/lt-ruby">Ruby Instarepl</a></p>
</li>
<li>
<p><a href="https://github.com/jetaggart/light-haskell">Haskell plugin</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>I haven&#8217;t worked with any of the above mentioned languages, but they did provide enough inspiration to deduce how a Light Table client might interact.</p>
</div>
<div class="paragraph">
<p>BTW. A quick starter just to get you up an running with a hello world plugin could be this screen cast by Mike Haney.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_connecting_a_client_process_overview">Connecting a client - Process overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before we dwelve into the code It&#8217;s a good idea to have a high level understanding of what we are trying to achieve !</p>
</div>
<div class="ulist">
<div class="title">A couple of use cases that needs to be supported:</div>
<ul>
<li>
<p>Evaluate current selection or current line of groovy code and present results (preferably inline)</p>
</li>
<li>
<p>Evaluate contents of current editor and present results</p>
</li>
<li>
<p>Provide as much info about the results of each statement as possible</p>
</li>
<li>
<p>(Maybe need to evaluate line/statement by statement)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For a future instarepl, any change in the editor will trigger an evaluation
It becomes evident that our plugin needs to provide some kind of process that reacts to events from light table.</p>
</div>
<div class="olist arabic">
<div class="title">A default pattern for achieving this has been devised for Light Table and roughly equates to the following steps:</div>
<ol class="arabic">
<li>
<p>A connect event is triggered from Light Table (you need to set up your plugin to trigger that event?). Typically the connect event can be invoked manually from the connect bar in light table, or it can be triggered implicetly when evaluating code.</p>
</li>
<li>
<p>You fire of a process - Using inbuilt support from Light Table you start a process either a shell script or whatever really. I created a shell script that sets some environment stuff and then basically kicks off a groovy script. Light table provides a tcp/ip port and a unique client id which you need to forward to the process.</p>
</li>
<li>
<p>Create a tcp client: In your process you create a tcp client using the given port</p>
</li>
<li>
<p>Send ack message: Send a json message with client id and an event name (behavior) to Light Table (through the tcp connection!)</p>
</li>
<li>
<p>Confirm handshake for process: In your process (i.e. not the tcp connection!) write "Connected" to standard out. ("Connected" is just what the other plugins use, you could use  anything you like as long as it matches the connect behaviors(handlers) you provide inside light table.)</p>
</li>
<li>
<p>Listen for events: Now you are connected and given you have set up your behaviors in Light Table correctly, your new connection should be reported as connected and shown in the Light Table connect bar. Now you listen for events on your tcp client and provides appropriate responses back to Light Table accordingly. (Handling this is the subject of a future blog post)</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_behaviors_for_connecting_from_groovy_cljs">Behaviors for connecting (from groovy.cljs):</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>(defn run-groovy[{:keys [path name client] :as info}]
  (let [obj (object/create ::connecting-notifier info)
        client-id (clients/-&gt;id client)
        project-dir (files/parent path)]
    (object/merge! client {:port tcp/port
                           :proc obj})
    (notifos/working "Connecting..")
    (proc/exec {:command binary-path
                :args [tcp/port client-id project-dir]
                :cwd plugin-dir
                :env {"GROOVY_PATH" (files/join (files/parent path))}
                :obj obj})))

(defn check-groovy[obj]
  (assoc obj :groovy (or (::groovy-exe @groovy)
                         (.which shell "groovy"))))

(defn check-server[obj]
  (assoc obj :groovy-server (files/exists? server-path)))

(defn handle-no-groovy [client]
  (clients/rem! client)
  (notifos/done-working)
  (popup/popup! {:header "We couldn't find Groovy."
                 :body "In order to evaluate in Groovy files, Groovy must be installed and on your system PATH."
                 :buttons [{:label "Download Groovy"
                            :action (fn []
                                      (platform/open "http://gvmtool.net/"))}
                           {:label "ok"}]}))

(defn notify [obj]
  (let [{:keys [groovy path groovy-server client]} obj]
    (cond
     (or (not groovy) (empty? groovy)) (do (handle-no-groovy client))
     :else (run-groovy obj))
    obj))

(defn check-all [obj]
  (-&gt; obj
      (check-groovy)
      (check-server)
      (notify)))

(defn try-connect [{:keys [info]}]
  (.log js/console (str "try connect" info))
  (let [path (:path info)
        client (clients/client! :groovy.client)]
    (check-all {:path path
                :client client})
    client))


(object/object* ::groovy-lang
                :tags #{:groovy.lang})


(def groovy (object/create ::groovy-lang))

(scl/add-connector {:name "Groovy"
                    :desc "Select a directory to serve as the root of your groovy project... then again it might not be relevant..."
                    :connect (fn []
                               (dialogs/dir groovy :connect))})
(behavior ::connect
                  :triggers #{:connect}
                  :reaction (fn [this path]
                              (try-connect {:info {:path path}})))
</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Notes:</div>
<ul>
<li>
<p>scl/add-connector: This statement adds a connect dialog to our groovy plugin. You select a root directory and upon selection the ::connect behavior is triggered</p>
</li>
<li>
<p>::connect basically responds with invoking a method for connecting. This does some sanity checks and if all goes well ends up invoking  run-groovy.</p>
</li>
<li>
<p>run-groovy : Fires up our groovy (server) process</p>
</li>
<li>
<p>def groovy   is basically the "mother" object of our plugin. It helps us scope behaviors and commands</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_the_server_part_ltserver_groovy">The server part (LTServer.groovy)</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>import groovy.json.*

params = [
  ltPort:   args[0].toInteger(),
  clientId: args[1].toInteger() // light table generated id for the client (connection)
]

logFile = new File("server.log")

def log(msg) {
  logFile &lt;&lt; "${new Date().format('dd.MM.yyyy mm:hh:sss')} - $msg\n"
}

client = null
try {
  client = new Socket("127.0.0.1", params.ltPort)
} catch (Exception e) {
  log "Could not connect to port: ${params.ltPort}"
  throw e
}

def sendData(data) {
  client &lt;&lt; new JsonBuilder(data).toString() + "\n"
}
// ack to Light Table
sendData (
  [
    name: "Groovy",
    "client-id": params.clientId,
    dir: new File("").absolutePath,
    commands: ["editor.eval.groovy"],
    type: "groovy"
  ]
)
println "Connected" // tells lighttable we're good

client.withStreams {input, output -&gt;
  while(true) {
  // insert code to listen for events from light table and respond to those (eval code etc)
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_notification_of_successful_connection">Notification of successful connection</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>(behavior ::on-out
          :triggers #{:proc.out}
          :reaction (fn [this data]
                      (let [out (.toString data)]
                        (object/update! this [:buffer] str out)
                        (if (&gt; (.indexOf out "Connected") -1)
                          (do
                            (notifos/done-working)
                            (object/merge! this {:connected true}))
                          (object/update! this [:buffer] str data)))))

(behavior ::on-error
          :triggers #{:proc.error}
          :reaction (fn [this data]
                      (let [out (.toString data)]
                        (when-not (&gt; (.indexOf (:buffer @this) "Connected") -1)
                          (object/update! this [:buffer] str data)
                          ))
                      ))

(behavior ::on-exit
          :triggers #{:proc.exit}
          :reaction (fn [this data]
                      ;(object/update! this [:buffer] str data)
                      (when-not (:connected @this)
                        (notifos/done-working)
                        (popup/popup! {:header "We couldn't connect."
                                       :body [:span "Looks like there was an issue trying to connect
                                              to the project. Here's what we got:" [:pre (:buffer @this)]]
                                       :buttons [{:label "close"}]})
                        (clients/rem! (:client @this)))
                      (proc/kill-all (:procs @this))
                      (object/destroy! this)
                      ))

(object/object* ::connecting-notifier
                :triggers []
                :behaviors [::on-exit ::on-error ::on-out]
                :init (fn [this client]
                        (object/merge! this {:client client :buffer ""})
                        nil))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above behaviors basically handles signaling success, error or connection exits for our groovy client. As you can see in ::on-out this is where we check standard out from the process for the string "Connected", to signal success.</p>
</div>
</div>
<div class="sect2">
<h3 id="_wiring_up_behaviors_behaviors_groovy">Wiring up behaviors (behaviors.groovy)</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint clojure language-clojure"><code>{:+ {:app [(:lt.objs.plugins/load-js ["codemirror/groovy.js", "groovy_compiled.js"])]
     :clients []
     :editor.groovy []
     :files [(:lt.objs.files/file-types
              [{:name "Groovy" :exts [:groovy] :mime "text/x-groovy" :tags [:editor.groovy]}])]
     :groovy.lang [:lt.plugins.groovy/connect]}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The important part in terms on the connection is the wiring of the connect behavior to ":groovy.lang". This is needed for groovy to appear as a connection item in the light table connect bar.</p>
</div>
<div class="paragraph">
<p>"codemirror/groovy.js" deserves a special mention. This is what provides syntax highlighting for our groovy files (defined in the :files vector). The syntax highlighting is provided by the groovy mode module from CodeMirror.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_wrapping_up">Wrapping up</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So what have we achieved. Well we now have a connection to Light Table from an external process that can listen and respond to events from Light Table. For the purposes of this blog post series, its a Groovy client that hopefully pretty soon will be able to evaluate groovy scripts and respond with evaluation results. We didn&#8217;t pay much attention to it, but we also got syntax highlighting of our Groovy files complements of CodeMirror.</p>
</div>
<div class="paragraph">
<p>It took a while to grok how the connection part worked. Once I did understand roughly what was needed I was a bit annoyed with myself for messing about so much. I&#8217;m hoping this post might help others to avoid some of the mistakes I stumbled into.</p>
</div>
</div>
</div></p>
  			<a href="/blog/2013/buster-plugin.html"><h1>Javascript testing in your JVM projects using Gradle and BusterJS</h1></a>
  			<p>19 August 2013</p>
        <p><em>Tags: </em>
		      <a href="/blog/tags/gradle.html">gradle</a>
	      
		      <a href="/blog/tags/groovy.html"> groovy</a>
	      
		      <a href="/blog/tags/javascript.html"> javascript</a>
	      
		      <a href="/blog/tags/buster.html"> buster</a>
	      
		      <a href="/blog/tags/screencast.html"> screencast</a>
	      </p>
  			<p><div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When I first started looking at testing in javascript land a while back I quickly felt lost in space.</p>
</div>
<div class="ulist">
<div class="title">Filled with questions like;</div>
<ul>
<li>
<p>which framework(s) to choose ?</p>
</li>
<li>
<p>how do I get framework x to work from my IDE ?</p>
</li>
<li>
<p>more importantly how to I manage to include the javascript tests in my CI builds ?</p>
</li>
<li>
<p>how can I avoid repetitive setup pain across projects ?</p>
</li>
<li>
<p>why is it such a hassle getting started ?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>I can&#8217;t say I have answered any of the questions above fully, but I have taken some strides in the right direction.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_buster_js">Buster.JS</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="http://docs.busterjs.org/en/latest/">Buster</a> is a flexible and modularized framework for writing and running your JavaScript tests.
There are others out there, but from what I could gather and based on advice from my frontend wizard colleagues I decided to give it a good go. It&#8217;s still in beta, but from my experiences so far its more than mature enough for proper use in projects.</p>
</div>
<div class="sect2">
<h3 id="_a_few_important_aspects_about_buster_js">A few important aspects about Buster.JS:</h3>
<div class="paragraph">
<p>Tests are run in real browsers (phantomjs for headless). No emulation bull
You can run tests in multiple browsers in parallell
Its really really fast
Write tests in the fashion that suits you (xUnit or spec)
Nice assertion library and integrated with Sinon.JS (powerful stubbing and spying)
&#8230; and lots more</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_gradle_buster_plugin">Gradle buster plugin</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For my jvm project builds I use Gradle. Maven and Ant projects that spend time with me a few weeks tend to find themselves converted. So I set out to create a buster plugin for gradle, aptly named gradle-buster-plugin. Still early days, but already it has started to prove quite valuable.</p>
</div>
<div class="ulist">
<div class="title">The plugin has two high-level goals;</div>
<ul>
<li>
<p>Allow you to easily run javascripts as part of your CI builds</p>
</li>
<li>
<p>Provide you with a smooth development experience by adding value on top of whats already present in Buster.JS.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The homepage for the pluging is here: <a href="https://github.com/rundis/gradle-buster-plugin">https://github.com/rundis/gradle-buster-plugin</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_do_i_have_to_do_aka_getting_started">What do I have to do ? (aka getting started)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_installing_preconditions">Installing preconditions</h3>
<div class="ulist">
<ul>
<li>
<p>Install node.js/npm - Mac: $ brew install node</p>
</li>
<li>
<p>Install Buster.JS  - $ npm install buster -g</p>
</li>
<li>
<p>Install Phantom.JS  - Mac: $ brew install phantomjs</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_set_up_the_buster_plugin_in_your_gradle_config">Set up the buster plugin in your gradle config</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>buildscript {
    repositories { jcenter() }
    dependencies {
        classpath  'org.gradle.buster:gradle-buster-plugin:0.2.4.1'
    }
}

apply plugin: 'war' // just assuming you have a war project
apply plugin: 'buster'

build.dependsOn busterTest // hook up javascript task in the build</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_set_up_a_buster_js_configuration_file">Set up a buster.js configuration file</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint javascript language-javascript"><code>var config = module.exports;

config["Sample JSTests"] = {
    environment: "browser",

    libs: ["src/main/webaapp/js/libs/jquery-1.10.2.js"],
    sources: ["src/main/web-app/js/app/**/*.js"],
    tests: ["src/test/js/**/*-test.js"]
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sample_unit">Sample unit</h3>
<div class="paragraph">
<p>So you could create a file like src/main/webapp/js/app/dummy-service.js</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint javascript language-javascript"><code>var myapp = this.myapp || {};
myapp.services = app.services || {};
(function () {
    myapp.services.DummyService = function (my) {
        my.listTodos = function(success, error) {
            $.get('/todos/list')
               .done(function(data) {
                  success(data);
               })
               .fail(function(jqXHR, textStatus, errorThrown) {
                  error("Error getting todos")
               });
        };
        return my;
    }(myapp.services.DummyService || {});
}());</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sample_unit_test">Sample unit test</h3>
<div class="paragraph">
<p>Create a corresponding unit test in src/test/js/app/dummy-service-test.js</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint javascript language-javascript"><code>(function () {
    buster.testCase("DummyService", {
        setUp: function() {
            this.service = myapp.services.DummyService;
            this.server = sinon.fakeServer.create();
            this.success = this.spy();
            this.error = this.spy();
        },
        tearDown: function () {
            this.server.restore();
        },
        "should successfully list todos": function () {
            this.service.listTodos(this.success, this.error);
            this.server.requests[0].respond(
                200,
                { "Content-Type": "application/json" },
                JSON.stringify([{ id: 1, text: "Provide examples", done: true }])
            );

            assert.calledOnce(this.success);
        },
        "should invoke error callback on errors": function () {
            this.service.listTodos(this.success, this.error);
            this.server.requests[0].respond(
                500,
                { "Content-Type": "application/json" },
                JSON.stringify([{ id: 1, text: "dummy", done: true }])
            );

            assert.calledOnce(this.error);
        }
    });
}());</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_running_the_tests_locally">Running the tests locally</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint bash language-bash"><code>$ gradle busterTest</code></pre>
</div>
</div>
<div class="paragraph">
<p>Test results are found in : build/busterTest-results/bustertests.xml</p>
</div>
<div class="paragraph">
<p>Autotesting
When doing your tdd cycles its quite useful to use the autotest feature (kinda like infinitest).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint bash language-bash"><code>$ gradle busterAutoTest</code></pre>
</div>
</div>
<div class="paragraph">
<p>Will leave the server running and listen for file changes in the patterns specified by the buster.js file above. So if I change the test or unit above a test run will automatically be fired off and results reported to the console. Its pretty fast so you should be able to keep a good flow going !
Just do Ctrl + C to kill the autotesting.</p>
</div>
<div class="paragraph">
<p>Multiple browsers
Its quite easy to set up just see the readme for the plugin</p>
</div>
<div class="paragraph">
<p>CI Server
Obviously you will need to set up the preconditions. If you&#8217;re server isn&#8217;t headless you have the option of testing with a few proper browsers(firefox and chrome on linux, safari if your server is mac&#8230; which I doubt).</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Its certainly not perfect, but with the above you have a pretty good start. Once you get over the hurdle of setting up the preconditions it really is quite pleasant to work with. You should be amazed by the performance of the tests runs if you are from a jvm background.
What about IDE integration ? With the autotest feature I can&#8217;t say I have missed it much. I have my IDE and a visible console available and get instant feedback on saves in my IDE.</p>
</div>
<div class="paragraph">
<p>Smooth !</p>
</div>
</div>
</div></p>

	<hr />

	<p>Older posts are available in the <a href="/blog/archive.html">archive</a>.</p>

		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
        <p class="muted credit">&copy; 2014 | Mixed with <a href="http://getbootstrap.com/">Bootstrap v3.1.1</a> | Baked with <a href="http://jbake.org">JBake v2.3.0</a></p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="js/jquery-1.11.1.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/prettify.js"></script>
    
  </body>
</html>